# Mysql basic knowledge
# SQL
# Data type
# 存储引擎
# 索引
# Transactions
# 锁机制
# 性能优化
# 分区分库
----
# Mysql 框架
![image](https://user-images.githubusercontent.com/27160394/140594674-19156356-f2ba-42d7-9401-b8cab5168324.png)

## 1. 网络连接层
客户端和连接服务。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。

### 组件
* Connectors:负责与其他编程语言的sql语言进行交互
* 连接池组建 (Connection Pool): MySQL会为每一个连接绑定一个线程,之后这个连接上的所有查询都在这个线程中执行.MySQL通常会缓存线程或者使用线程池,从而避免频繁的创建和销毁线程。



如何解决这个问题
1. 定期断开长连接；
2. `mysql_reset_connection`来重新初始化连接资源，这时不需要重新连接，就可以将连接恢复到刚刚创建完时的状态
3. 数据库连接池 : 

## 2.服务层
>负责查询处理和其他系统任务。
主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储

### 组件
* 管理服务和工具组建 (Enterprise Management Services & Utilities)
* SQL接口组件（SQL Interface）: MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口。
* 查询分析器（Parser): MySQL会解析SQL查询,并为其创建语法树,并根据数据字典丰富查询语法树,会验证该客户端是否具有执行该查询的权限.创建好语法树后,MySQL还会对SQl查询进行语法上的优化，进行查询重写
* 优化器组件（Optimizer）:语法解析和查询重写之后,MySQL会根据语法树和数据的统计信息对SQL进行优化,包括决定表的读取顺序、选择合适的索引等，最终生成SQL的具体执行步骤。这些具体的执行步骤里真正的数据操作都是通过预先定义好的存储引擎API来进行的，与具体的存储引擎实现无关
* 缓冲组件（Cache & Buffer）: MySQL内部维持着一些Cache和Buffer,比如Query Cache用来缓存一条Select语句的执行结果,如果能够在其中找到对应的查询结果,那么就不必再进行查询解析、优化和执行的整个过程了

## 3. 引擎层
> 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信

MySQL可以动态安装或移除存储引擎，可以有多种存储引擎同时存在，可以为每个Table设置不同的存储引擎。存储引擎负责在文件系统之上，管理表的数据,索引的实际内容,同时也会管理运行时的Cache、Buffer、事务、Log等数据和功能

### 组件
* Pluggable Storage Engine:负责与具体的文件系统交互
  * MySQL可以动态安装或移除存储引擎，可以有多种存储引擎同时存在，可以为每个Table设置不同的存储引擎。
  * 存储引擎负责在文件系统之上，管理表的数据、索引的实际内容，同时也会管理运行时的Cache、Buffer、事务、Log等数据和功能 

### 存储引擎类别
* InnoDB 存储引擎：Mysql 5.5版本后默认的存储引擎，优点是支持事务，行级锁，外键约束，支持崩溃后的安全恢复；
* MyISAM 存储引擎：不支持事务和外键，支持全文索引（但只对英文有效），特点是查询速度快；
* Memory 存储引擎：数据放在内存当中（类似memcache）以便得到更快的响应速度，但是崩掉的话数据会丢失；
* NDB 存储引擎：主要用于Mysql Cluster分布式集群；
* Archive 存储引擎：有很好的压缩机制，用于文件归档，写入时会进行压缩；


## 4.存储层

是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互

### 组件
* 物理文件(File System,Files & Logs): 所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统上，以文件的方式存在的


## MySQL 的查询流程具体是？or 一条SQL语句在MySQL中如何执行的

1. 客户端请求
2. 连接器（验证用户身份，给予权限）
3. 查询缓存（存在缓存则直接返回，不存在则执行后续操作）
4. 分析器（对SQL进行词法分析和语法分析操作）
5. 优化器（主要对执行的sql优化选择最优的执行方案方法）
6. 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）
7. 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）


## 一条SQL更新语句是如何执行的

1. 先连接数据库（连接器）
2. 在一个表上更新时，与该表有关的查询缓存会失效，所以该语句会将表T上所有的缓存结果都清空；
3. 将SQL语句进行词法分析，并检测SQL语法(分析器)
4. 然后优化对应的查询操作(优化器)
5. 执行器负责具体执行，找到这一行，进行更新

查询语句只需要返回查询结果即可，但是更新语句需要去真的修改数据库中的数据，所以更新语句相对来讲要复杂一些.更新流程还涉及两个重要的日志模块 redolog(重做日志)和 binlog(归档日志）

每一次的更新操作都需要写进磁盘,然后磁盘也要找到对应的那条记录,然后再更新,整个过程IO成本,查找成本都很高.MySQL的设计者Write-Ahead Logging，它的关键点就是先写日志，再写磁盘.
* 执行一条更新语句，InnoDB就会先把记录写到redo log里面，然后更新到内存，等到系统比较空闲的时候再写入磁盘。redo log的文件大小是固定的，是通过循环写的 实现的

*重做日志(redo log)和归档日志(binlog)*
Redo log
> 为了解决crash-safe问题而产生的，是一种物理日志
redo log是InnoDB引擎层的一种日志，是用来记录这个页"做了什么改动"
![image](https://user-images.githubusercontent.com/27160394/140596469-31603a55-eb39-48cb-8ff7-b7faa87a6b8b.png)
* redo log的文件大小是固定的，会循环写入文件,一边写一边后移，写到第3号文件末尾后就回到0号文件开头,checkpoint也是往后推移并且循环的,擦除记录前要把记录更新到数据文件
* write pos和checkpoint之间还空着的部分，可以用来记录新的操作
* 如果write pos追上checkpoin，表示redo log满了，这时候不能再执行新的更新，得停下来先擦掉一些记录

Binlog
> 一种逻辑日志，是Server层的一种日志，记录了所有的sql语句，主要是用来配合备份来恢复数据库的
只要我们有最近一次的备份和这期间完整的binlog就能够恢复数据库了
* binlog是追加写，写到一定大小后会切换到下一个，并不会覆盖以前的日志

两阶段提交
1. UPDATE语句的结果写入内存，同时将这个操作写入redo log，此时redo log处于prepare状态，并告知执行器随时可以提交事物
2. 执行器生成这个操作的binlog，并写入binlog日志. 
3. 执行器通知将之前处于prepare状态改为commit状态，更新完成。

两个阶段提交保证了redo log和binlog的一致性
* 先写redo log后写binlog,redo log会恢复crash的语句，但是如果用这产生时的binlog去恢复数据库就会丢失这条记录，此时两个日志恢复的数据库数据就产生了差异
* 先写binlog后写redo log,redo log中还没写,此时异常重启后这个事务是无效的,所以无法恢复,但是binlog中有这条数据,当用此时的binlog文件去恢复数据库的时候,就会比当前的数据库数据多一条记录。

执行器和InnoDB引擎在执行这个简单的update语句时的内部流程:
1. 执行器先找引擎取ID=2这一行，ID是主键，引擎直接用树搜索找到这一行，如果ID=2这一行所在的数据页本就在内存中，就直接返回给执行器，否则需要从磁盘读入再返回；
2. 执行器拿到引擎给的行数据后，将值加1，原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据；
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务
4. 执行器生成这个操作的binlog，并把binlog写入磁盘
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成
6. Redo log的写入拆成了两个步骤：prepare和commit，这就是"两阶段提交"。
7. 
![image](https://user-images.githubusercontent.com/27160394/140596830-ff8ff742-f9cc-4106-b40a-a4c76dbbec67.png)

Note
* Redo log不是记录数据页“更新之后的状态”，而是记录这个页 “做了什么改动”。
* Binlog有两种模式，statement 格式的话是记sql语句,row格式会记录行的内容,记两条,更新前和更新后都有。

---
# Basic SQL
## SQL 分类
* DDL（Data Definition languages):定义了不同的数据段,数据库,表,列,索引等数据库对象的定义。常用的语句关键字主要包括 create、drop、alter 等。
* DML(Data Manipulation Language)语句:CRUD=，并检查数据完整性，常用的语句关键字主要包括 insert、delete、udpate 和 select 等。
* DCL(Data Control Language)语句:用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别.主要的语句关键字包括 grant、revoke等。

## DDL
它和DML语言的最大区别是DML只是对表内部数据的操作,而不涉及到表的定义,结构的修改,更不会涉及到其他对象.DDL语句更多的被数据库管理员(DBA)所使用

<img width="420" alt="Screen Shot 2021-11-06 at 12 08 29 PM" src="https://user-images.githubusercontent.com/27160394/140597425-7305b30e-d1df-48eb-84c4-5a858b9581af.png">

* information_schema:主要存储了系统中的一些数据库对象信息。比如用户表信息、列信 息、权限信息、字符集信息、分区信息等。
* cluster:存储了系统的集群信息。
* mysql:存储了系统的用户权限信息。
* test:系统自动创建的测试数据库，任何用户都可以使用。

```
create database test1;
show databases;
uses test1;
show tables;
drop test1;
create table emp(ename varchar(10),hiredate date,sal decimal(10,2),deptno int(2));
desc emp;//需要查看一下表的定义
show create table emp 
drop table emp;
alter table emp modify ename varchar(20);
alter table emp add column age int(3);
alter table emp drop column age;
alter table emp change age age1 int(4); //can rename,but modify can't
alter table emp add birth date after ename;
alter table emp modify age int(3) first;
```
## DML
DML 操作是指对数据库中表记录的操作,是开发人员日常使用最频繁的操作
```
insert into emp (ename,hiredate,sal,deptno) values('zzx1','2000-01-01','2000',1);
insert into emp values('lisa','2003-02-01','3000',2);//没写的字段可以自动设置为 NULL、 默认值、自增的下一个数字
insert into dept values(5,'dept5'),(6,'dept6');
update emp set sal=4000 where ename='lisa';
delete from emp where ename='dony';
select * from emp;
select distinct deptno from emp;
select * from emp where deptno = 1;
select * from emp where deptno=1 and sal<3000;

// 排序和分页
select * from emp order by sal;//关键字默认是升序排列,
select * from emp order by deptno,sal desc;//如果排序字段的值一样，则值相同的字段按照第二个排序字段进行排序
select * from emp order by sal limit 3;
select * from emp order by sal limit 1,3;//limit 经常和 order by 一起配合使用来进行记录的分页显示

// 聚合: sum,count,max,mni(聚合函数)， GROUP BY（分类聚合),WHTH ROLLUP 对分类聚合后的结果进行再汇总,HAVING对分类后的结果再进行条件的过滤
select deptno,count(1) from emp group by deptno with rollup;// 既要统计各部门人数，又要统计总人数
select deptno,count(1) from emp group by deptno having count(1)>1;// having 和 where 的区别在于 having 是对聚合后的结果进行条件的过滤，而 where是在聚合前就对记录进行过滤

//表连接: 内连接和外连接,它们之间的最主要区别是內连接仅选出两张表中互相匹配的记录,而外连接会选出其他不匹配的记录
select ename,deptname from emp,dept where emp.deptno=dept.deptno;
select ename,deptname from emp left join dept on emp.deptno=dept.deptno;//外连接有分为左连接和右连接:包含所有的左边表中的记录甚至是右边表中没有和它匹配的记录

//子查询
select * from emp where deptno in(select deptno from dept);//如果子查询记录数唯一，还可以用=代替 in
select emp.* from emp ,dept where emp.deptno=dept.deptno;// 表连接在很多情况下用于优化子查询

// 记录联合(union): join 是两张表根据条件相同的部分合并生成一个记录集。union是产生的两个记录集(字段要一样的)并在一起，成为一个新的记录集 。
SELECT * FROM t1 UNION|UNION ALL SELECT * FROM t2 // UNION 是将 UNION ALL 后的结果进行一次 DISTINCT，去除重复记录后的结果。
```
### MySQL查询
> `count(*)`和`count(1)`和`count(列名)`区别
COUNT 函数是一个聚合函数，它返回符合条件行数.

COUNT(常量) 和 `COUNT(*)` 表示的是直接查询符合条件的数据库表的行数,COUNT(列名)表示的是查询符合条件的列的值不为NULL的行数。
* `count(*)`包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL  
* `count(1)`基本上只是为每行计算一个常量值 1 列，在统计结果的时候，不会忽略列值为NULL 
* `count(列名)`只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计
* MyISAM做了一个简单的优化，把表的总行数单独记录下来，如果执行`count(*)`时可以直接返回，前提是不能有where条件


执行效率
* 列名为主键,count(列名)会比count(1)快
* 列名不为主键count(1)会比count(列名)快
* 如果表多个列并且没有主键，则 count(1) 的执行效率优于`count(*)`
* 如果有主键，则 select count（主键）的执行效率是最优的
* 如果表只有一个字段，则`select count(*)`最优
* 如果该表只有一个主键索引,没有任何二级索引的情况下,那么`COUNT(*)`和`COUNT(1)`都是通过通过主键索引来统计行数的。
* 如果该表有二级索引，则`COUNT(1)`和`COUNT(*)`都会通过占用空间最小的字段的二级索引进行统计,也就是说虽然COUNT(1)指定了第一列（此处表达有误，详见文章结尾）但是innodb不会真的去统计主键索引

> 在INNODB与MYISAM中统计当前数据行，用`count(*)`有什么区别
* MyISAM `COUNT(*)`is optimized to return very quickly if the SELECT retrieves from one table, no other columns are retrieved, and there is no WHERE clause.This optimization only applies to MyISAM tables,because an exact row count is stored for this storage engine and can be accessed very quickly
* InnoDB不保存表的具体行数，执行`count(*)`时需要全表扫描。那么为什么InnoDB没有了这个变量呢？因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询.

> MySQL中 in和 exists 的区别？
* in是把外表和内表做hash连接，先查询内表，再把内表结果与外表匹配，对外表使用索引（外表效率高，可用大表),而内表多大都需要查询,不可避免,故外表大的使用in,可加快效率
* exists是对外表做loop循环，每次loop循环再对内表（子查询）进行查询，那么因为对内表的查询使用的索引（内表效率高，故可用大表），而外表有多大都需要遍历，不可避免（尽量用小表），故内表大的使用exists，可加快效率
* 如果查询的两个表大小相当，那么用in和exists差别不大。
* IN适合于外表大而内表小的情况；
* EXISTS适合于外表小而内表大的情况。
* 如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。

> UNION和UNION ALL的区别?
UNION和UNION ALL都是将两个结果集合并为一个，两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；
* UNION在进行表连接后会筛选掉重复的数据记录（效率较低），而UNION ALL则不会去掉重复的数据记录；
* UNION会按照字段的顺序进行排序，而UNION ALL只是简单的将两个结果合并就返回；



##  DCL
主要是 DBA 用来管理系统中的对象权限时所使用
```
grant select,insert on sakila.* to 'z1'@'localhost' identified by '123
```

手写顺序
```
SELECT DISTINCT <select_list>
FROM  <left_table> <join_type>
JOIN  <right_table> ON <join_condition>
WHERE  <where_condition>
GROUP BY  <group_by_list>
HAVING <having_condition>
ORDER BY <order_by_condition>
LIMIT <limit_number>

```
机读顺序
```
FROM  <left_table>
ON <join_condition>
<join_type> JOIN  <right_table> 
WHERE  <where_condition>
GROUP BY  <group_by_list>
HAVING <having_condition>
SELECT
DISTINCT <select_list>
ORDER BY <order_by_condition>
LIMIT <limit_number>
```
---
# MySQL 支持的数据类型
> MySQL 提供了多种数据类型,主要包括数值型、字符串类型、日期和时间类型
## 数值类型
MySQL 支持所有标准 SQL 中的数值类型
* 严格数值类型(`INTEGER、SMALLINT、DECIMAL 和 NUMERIC`)
* 近似数值数据类型(`FLOAT、REAL 和 DOUBLE PRECISION`)
* 增加了 `TINYINT、MEDIUMINT 和 BIGINT` 这 3 种长度不同的整型，
* 并增加了 `BIT` 类型，用来存放位数据

<img width="470" alt="Screen Shot 2021-11-06 at 12 57 46 PM" src="https://user-images.githubusercontent.com/27160394/140598537-ba4b44d5-d665-44c4-b7b5-c238a04e6b3c.png">

### 整形数据

对于整型数据,MySQL 还支持在类型名称后面的小括号内指定显示宽度
* 例如 int(5)表 示当数值宽度小于5位的时候在数字前面填满宽度，如果不显示指定宽度则默认为 int(11)
* 一般配合 zerofill 使用，顾名思义，zerofill 就是用“0”填充的意思，也就是在数字位数不够 的空间用字符“0”填满

所有的整数类型都有一个可选属性 UNSIGNED(无符号)，如果需要在字段里面保存非负数或者需要较大的上限值时，可以用此选项，
* 它的取值范围是正常值的下限取 0，上限取 原值的 2 倍
* tinyint 有符号范围是-128~+127，而无符号范围是 0~255。
* 如果一个列 指定为 zerofill，则 MySQL 自动为该列添加 UNSIGNED 属性

整数类型还有一个属性:AUTO_INCREMENT
* 在需要产生唯一标识符或顺序值时,可利用此属性
* 一个表中最多只能有一个AUTO_INCREMENT列。
* 对于任何想要使用AUTO_INCREMENT 的 列，应该定义为 NOT NULL
* 并定义为 PRIMARY KEY 或定义为 UNIQUE 键
```
CREATE TABLE AI(ID INT AUTO_INCREMENT NOT NULL ,PRIMARY KEY(ID));
```
###  小数数据
对于小数的表示，MySQL 分为两种方式:浮点数和定点数
* 浮点数包括 float(单精度) 和 double(双精度)
* 而定点数则只有 decimal 一种表示: 定点数在 MySQL 内部以字符串形 式存放，比浮点数更精确，适合用来表示货币等精度高的数据。

浮点数和定点数都可以用类型名称后加“(M,D)”的方式来进行表示，“(M,D)”表示该值一共显示M位数字(整数位+小数位)，其中D位位于小数点后面
* float 和 double 在不指定精度时，默认会按照实际的精度(由实际的硬件和操作系统决定
* 如果有精度和标度，则会自动将四舍五入后的结果插入,系统不会报错
```
float(7,4)列内插入999.00009 --> 999.0001//MySQL 保存值时进行四舍五入
```
`decimal`在不指定精度时，默认的整数位为 10，默认的小数位为 0。
 * 默认字段的小数位被截断
 * 并且如果数据超越了精度和标度值，系统则会报错

`BIT` 用于存放位字段值，BIT(M)可以用来存放多位二进制数，M 范围从 1~ 64，如果不写则默认为 1 位.
* 对于位字段，直接使用 SELECT 命令将不会看到结果
* 可以用 `bin()`(显示为二进制格式)或者`hex()`(显示为十六进制格式)函数进行读取

#### 选择场景
* 浮点型插入数据的精度超过该列定义的实际精度，则插入值会被四舍五入到实际定义的精度值
* 定点数不同于浮点数,定点数实际上是以字符串形式存放的,所以定点数可以更加精确的保存数据
* 编程中应尽量避免浮点数的比较，如果非要使用浮点数比较则 最好使用范围比较而不要使用“==”比较


## 日期时间类型
<img width="493" alt="Screen Shot 2021-11-06 at 1 14 22 PM" src="https://user-images.githubusercontent.com/27160394/140598856-0e9fc08e-f730-478e-98f0-9edd97066f11.png">

|Data type| 使用场景|
|---------|---------|
|`DATE`|如果要用来表示年月日|
|`DATETIME`|如果要用来表示年月日时分秒|
|`TIME`|只用来表示时分秒|
|`TIMESTAMP`|需要经常插入或者更新日期为当前系统时间, 值返回后显示为“YYYY-MM-DD HH:MM:SS”格式的字符串，显示宽度固定为19个字符如果想要获得数字值,应在TIMESTAMP列添加+0|
|`YEAR`|表示年份,YEAR有2位或4位格式的年。默认是4位格式|


### 选择优化
* 根据实际需要选择能够满足应用的最小存储的日期类型.如果应用只需要记录“年份”,那么用1个字节来存储的`YEAR`类型完全可以满足,而不需要用`4`个字节来 存储的 DATE 类型。
* 如果要记录年月日时分秒，并且记录的年份比较久远，那么最好使用`DATETIME`， 而不要使用`TIMESTAM`。因为`TIMESTAMP`表示的日期范围比`DATETIME`要短得多
* 如果记录的日期需要让不同时区的用户使用，那么最好使用`TIMESTAMP`，因为日期类型中只有它能够和实际时区相对应


## 字符串类型
<img width="467" alt="Screen Shot 2021-11-06 at 1 27 17 PM" src="https://user-images.githubusercontent.com/27160394/140599097-e7de57aa-a86f-42b9-b525-dbac68e10cf6.png">

### CHAR 和 VARCHAR 类型
> 用来保存 MySQL 中较短的字符串
二者的主要区别在于存储方式的不同:
* `CHAR` 列的长度固定为创建表时声明的长度，长度可以为从 0~255 的任何值;
* `VARCHAR`列中的值为可变长字符串，长度可以指定为0~255(5 5.0.3以前)或者6553(5 5.0.3 以后)之间的值
* 在检索的时候，CHAR 列删除了尾部的空格，而 VARCHAR 则保留这些空格

#### 选择合适的数据类型
* 由于CHAR是固定长度的,所以它的处理速度比VARCHAR快得多，但是其缺点是浪费存储空间,程序需要对行尾空格进行处理,所以对于那些长度变化不大并且对查询速度有较高要求的数据可以考虑使用CHAR类型来存储
* MyISAM 存储引擎:建议使用固定长度的数据列代替可变长度的数据列
* MEMORY 存储引擎:目前都使用固定长度的数据行存储,两者都是作为 CHAR 类型处理
* InnoDB 存储引擎:建议使用`VARCHAR`类型。对于InnoDB数据表,内部的行存储格式没有区分固定长度和可变长度列,使用固定长度的 CHAR 列不一定比使用可变长度VARCHAR列性能要好


### BINARY 和 VARBINARY
类似于 CHAR 和 VARCHAR,它们包含二进制字符串 而不包含非二进制字符串


### TEXT 与 BLOB
> 在保存较大文本时， 通常会选择使用 TEXT 或者 BLOB，二者之间的主要差别是 BLOB 能用来保存二进制数据，比如照片;而TEXT只能保存字符数据,比如一篇文章或者日记

性能提升
* 删除操作会在数据表中留下很大的“空洞”，以后填入这些“空洞”的记录在插入的性能上会有影响。为了提高性能,建议定期使用`OPTIMIZE TABLE`功能对这类表进行碎片整理
* 可以使用合成的(Synthetic)索引来提高大文本字段(BLOB 或 TEXT)的查询性能.合成索引就是根据大文本字段的内容建立一个散列值,并把这个值存储在单独的数据列中,接下来就可以通过检索散列值找到数据行了
* 如果需要对BLOB或者CLOB字段进行模糊查询，MySQL提供了前缀索引，也就是只为字段的前n列创建索引, “%” 不能放在最前面，否则索引将不会被使用。
* 在不必要的时候避免检索大型的 BLOB 或 TEXT 值。
* 把BLOB或TEXT列分离到单独的表中,如果把这些数据列移动到第二张数据表中,可以把原数据表中的数据列转换为固定长度的数据行格式


### ENUM 类型
它的值范围需要在创建表时通过枚举方式显式指定,对 1~ 255个成员的枚举需要1个字节存储;对于 255~65535 个成员，需要2个字节存储
* 忽略大小写的，都转成了大写，还可以看出对于插入不在 ENUM 指定范围内的值时，并没有返回警告，而是插入第一值
* ENUM 类型只允许从值集合中选取单个值，而不能一次取多个值

### SET 类型
是一个字符串对象，里面可以包含 0~64 个成员
```
Create table t (col set ('a','b','c','d');
insert into t values('a,b'),('a,d,a'),('a,b'),('a,c'),('a');
```
* SET 类型可以从允许值集合中选择任意 1 个或多个元素进行组合
---
# MySQL 中的运算符
> 来连接表达式的项

算术运算符、比较 运算符、逻辑运算符和位运算符

## 算术运算符
<img width="405" alt="Screen Shot 2021-11-06 at 1 38 50 PM" src="https://user-images.githubusercontent.com/27160394/140599258-940ded9f-a575-4506-b8c4-c0b0eb475b97.png">

## 比较运算符
<img width="413" alt="Screen Shot 2021-11-06 at 1 41 22 PM" src="https://user-images.githubusercontent.com/27160394/140599317-2a67c454-8800-4685-af61-37765197080c.png">
* 比较运算符可以用于比较数字、字符串和表达式。数字作为浮点数比较，而字符串以不 区分大小写的方式进行比较
* `“=”`运算符，用于比较运算符两侧的操作数是否相等，如果两侧操作数相等返回值为1,否则为 0。注意`NULL`不能用于`“=”`比较
* <=>”安全的等于运算符，和“=”类似,不同之处在于即使 操作的值为 NULL 也可以正确比较
* `“BETWEEN”`运算符的使用格式为`“a BETWEEN min AND max”`
* `“IN”`运算符的使用格式为`“a IN (value1,value2,...)`
* `“LIKE”`运算符的使用格式为`“a LIKE %123%”`,当 a 中含有字符串“123”时，则返回 值为 1，否则返回 0
* `REGEXP`运算符的使用格式为`“str REGEXP str_pat”,`当 `str` 字符串中含有 `str_pat` 相匹配的字符串时，则返回值为 1，否则返回0

## 逻辑运算符
* `NOT` -> `!`,就是 NOT NULL 的返回值为 NULL
* `AND` -> `&&`
* `OR` -> `||`,假如两个操作数均为 NULL，则所得结果 为 NULL
* `XOR`

## 位运算符
<img width="373" alt="Screen Shot 2021-11-06 at 1 48 37 PM" src="https://user-images.githubusercontent.com/27160394/140599449-b4179fd3-3beb-4c4e-9553-468876309e72.png">

<img width="554" alt="Screen Shot 2021-11-06 at 1 49 52 PM" src="https://user-images.githubusercontent.com/27160394/140599471-f66d3dd9-1cf6-4c24-8d6a-7643b745a17d.png">
---
# 常用函数
MySQL 提供了多种内建函数帮助开发人员编写简单快捷的SQL语句，其中常用的函数有字符串函数,日期函数和数值函数

## 字符串函数
* CANCAT(S1,S2,...Sn)函数:把传入的参数连接成为一个字符串。
* INSERT(str ,x,y,instr)函数:将字符串 str 从第 x 位置开始，y 个字符长的子串替换为字符 串 instr
* LOWER(str)和 UPPER(str)函数:把字符串转换成小写或大写
* LEFT(str,x)和 RIGHT(str,x)函数:分别返回字符串最左边的x个字符和最右边的x个字符。 如果第二个参数是 NULL，那么将不返回任何字符串
* LPAD(str,n ,pad)和 RPAD(str,n ,pad)函数:用字符串 pad 对 str 最左边和最右边进行填充, 直到长度为 n 个字符长度
* LTRIM(str)和 RTRIM(str)函数:去掉字符串 str 左侧和右侧空格,TRIM(str)函数:去掉目标字符串的开头和结尾的空格。
* REPEAT(str,x)函数:返回 str 重复 x 次的结果。
* REPLACE(str,a,b)函数:用字符串 b 替换字符串 str 中所有出现的字符串 a。
* SUBSTRING(str,x,y)函数:返回从字符串 str 中的第 x 位置起 y 个字符长度的字串。

## 数值函数
<img width="367" alt="Screen Shot 2021-11-06 at 1 54 21 PM" src="https://user-images.githubusercontent.com/27160394/140599581-1871d7a7-46e4-4841-a367-76c313b7cf26.png">

## 日期和时间函数
<img width="399" alt="Screen Shot 2021-11-06 at 1 55 42 PM" src="https://user-images.githubusercontent.com/27160394/140599618-6686f73d-00bf-4cd0-bfa6-cade8f71bd13.png">

## 流程函数
<img width="309" alt="Screen Shot 2021-11-06 at 1 57 00 PM" src="https://user-images.githubusercontent.com/27160394/140599646-765a8902-859b-48f3-8d8d-0dbc3aa8911b.png">

```
select case salary when 1000 then 'low' when 2000 then 'mid' else 'high' end from salary;
```
---
# 存储引擎
> 负责MySQL中的数据的存储和提取,是与文件打交道的子系统.它是根据MySQL提供的文件访问层抽象接口定制的一种文件访问机制

MySQL 默认支持多种存储引擎，以适用于不同领域 的数据库应用需要，用户可以根据应用的需要选择如 何存储和索引数据、是否使用事务等。

MySQL 5.0 支持的存储引擎包括 MyISAM、InnoDB、BDB、MEMORY、MERGE、EXAMPLE、 NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED 等，其中 InnoDB 和 BDB 提供事务安 全表，其他存储引擎都是非事务安全表

默认情况下，创建新表不指定表的存储引擎，则新表是默认存储引擎的，如果需要修改 默认的存储引擎
* 在创建新表的时候，可以通过增加 ENGINE 关键字设置新建表的存储引擎
```
CREATE TABLE ai (i bigint(20) NOT NULL AUTO_INCREMENT, PRIMARY KEY (i)) ENGINE=MyISAM DEFAULT CHARSET=gbk;
-- 修改存储引擎
ALTER TABLE t ENGINE = InnoDB;
-- 修改默认存储引擎，也可以在配置文件my.cnf中修改默认引擎
SET default_storage_engine=NDBCLUSTER;
```
查看存储引擎
```
-- 查看支持的存储引擎
SHOW ENGINES

-- 查看默认存储引擎
SHOW VARIABLES LIKE 'storage_engine'

--查看具体某一个表所使用的存储引擎，这个默认存储引擎被修改了！
show create table tablename

--准确查看某个数据库中的某一表所使用的存储引擎
show table status like 'tablename'
show table status from database where name="tablename"
```
## 各种存储引擎的特性

### MyISAM
* 不支持事务
* 不支持外键
* 优势是访问的速度快
* 对事务完整性没有要求或者以SELECT,INSERT为主的应用基本上都可以使用这个引擎来创建表

每个 MyISAM 在磁盘上存储成 3 个文件，其文件名都和表名相同
* `.frm`(存储表定义);
* `.MYD`(MYData，存储数据);
* `.MYI` (MYIndex，存储索引)。


MyISAM 类型的表可能会损坏，原因可能是多种多样的，损坏后的表可能不能访问，会提示需要修复或者访问后返回错误的结果。
* MyISAM 类型的表提供修复的工具，可以用 CHECK TABLE 语句来检查 MyISAM 表的健康，
* 用 REPAIR TABLE 语句修复一个损坏的 MyISAM 表。

|MyISAM存储格式|特点|
|-------------|---|
|静态(固定长度)表|默认的存储格式。静态表中的字段都是非变长字段，这种存储方式的优点是存储非常迅速，容易缓存，出现故障容易恢复;缺点是占用的空间通常比动态表多|
|动态表|包含变长字段,记录不是固定长度的,这样存储的优点是占用的空间相对较少,但是频繁地更新删除记录会产生碎片，需要定期执行 OPTIMIZE TABLE 语句命令来改善性能，|
|压缩表|由 myisampack 工具创建，占据非常小的磁盘空间。因为每个记录是被单独压缩的，所以只有非常小的访问开支|

### InnoDB
* 提供了具有提交、回滚和崩溃恢复能力的事务安全
* 对比MyISAM的存储引擎,InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。

自动增长列
* InnoDB表的自动增长列可以手工插入,但是插入的值如果是空或者0,则实际插入的将\是自动增长后的值
* 可以通过“ALTER TABLE *** AUTO_INCREMENT = n;”语句强制设置自动增长列的初识值
* 可以使用 LAST_INSERT_ID()查询当前线程最后插入记录使用的值
* 对于 InnoDB 表，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一列，对于MyISAM表,自动增长列可以是组合索引的其他列

外键约束
* MySQL 支持外键的存储引擎只有 InnoDB
* 在创建外键的时候，要求父表必须有对应的索引.
* 子表在创建外键的时候也会自动创建对应的索引.
* RESTRICT和NO ACTION相同，是指限制在子表有关联记录的情况下父表不能更新;
* CASCADE 表示父表在更新或者删除时，更新或者删除子表对应记录
* SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被 SET NULL

InnoDB 物理文件结构为
* `.frm` 文件:与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等
* `.ibd` 文件或 `.ibdata `文件：这两种文件都是存放InnoDB数据的文件，之所以有两种文件形式存放InnoDB的数据，是因为InnoDB的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据，还是用独享表空间存放存储数据.

InnoDB 存储表和索引有以下两种方式
* 使用共享表空间存储,这种方式创建的表的表结构保存在`.frm`文件中,数据和索引保存在 `innodb_data_home_dir` 和 `innodb_data_file_path`定义的表空间中，可以是多个文件
* 使用多表空间存储，这种方式创建的表的表结构仍然保存在`.frm`文件中，但是每个表的数据和索引单独保存在`.ibd` 中。如果是个分区表,则每个分区对应单独的`.ibd` 文件，文件名是`表名+分区名`

使用多表空间特性的表,可以比较方便地进行单表备份和恢复操作,但是直接复制`.ibd` 文件是不行的《因为没有共享表空间的数据字典信息，直接复制的.ibd 文件和.frm 文 件恢复时是不能被正确识别的
```
 ALTER TABLE tbl_name DISCARD TABLESPACE; 
 ALTER TABLE tbl_name IMPORT TABLESPACE;
```
### MEMORY
MEMORY存储引擎使用存在内存中的内容来创建表.
* 每个 MEMORY表只实际对应一个磁盘文件
* 格式是`.frm`。MEMORY 类型的表访问非常得快，因为它的数据是放在内存中的
* 并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失掉。

使用场景
* MEMORY类型的存储引擎主要用在那些内容变化不频繁的代码表，或者作为统计操作的中间结果表便于高效地对中间结果进行分析并得到最终的统计结果
* 对 MEMORY存储引擎的表进行更新操作要谨慎,因为数据并没有实际写入到磁盘中,所以一定要对下次重新 启动服务后如何获得这些修改后的数据有所考虑

### MERGE
MERGE 存储引擎是一组 MyISAM 表的组合
* 这些 MyISAM表必须结构完全相同，
* MERGE表本身并没有数据，
* 对MERGE类型的表可以进行查询、更新、删除的操作，这些操作实际上是对内部的实际的 MyISAM表进行的
* 对于MERGE类型表的插入操作，是通过 `INSERT_METHOD` 子句定义插入的表，可以有3个不同的值，使用`FIRST`或 `LAST` 值使得插入操作被相应地作用在第一或最后一个表上

MERGE 表在磁盘上保留两个文件
* 文件名以表的名字开始，一个`.frm`文件存储表定义
* 另一个`.MRG`文件包含组合表的信息，包括MERGE表由哪些表组成、插入新的数据时的依据

特点
* MERGE表和分区表的区别，MERGE表并不能智能地将记录写到对应的表中，而分区表是可以的
* 通常我们使用MERGE表来透明地对多个表进行查询和更新操作,而对这种按照时间记录的操作日志表则可以透明地进行插入操作


## 如何选择合适的存储引擎

MyISAM
* 如果应用是以读操作和插入操作为主只有很少的更新和删除操作 
* 并且对事务的完整性,并发性要求不是很高，那么选择这个存储引擎是非常适合的。
* MyISAM 是在 Web，数据仓储和其他应用环境下最常使用的存储引擎

InnoDB
* 用于事务处理应用程序，支持外键
* 如果应用对事务的完整性有比较高的要求
* 在并发条件下要求数据的一致性,数据操作除了插入和查询以外，还包括很多的更新,删除操作
* innoDB 存储引擎有效地降低 由于删除和更新导致的锁定
* 还可以确保事务的完整提交(Commit)和回滚(Rollback)
* 对于类似计费系统或者财务系统等对数据准确性要求比较高的系统

MEMORY
* 将所有数据保存在RAM中,在需要快速定位记录和其他类似数据的环境下,可提供极快的访问。
* MEMORY的缺陷是对表的大小有限制，太大的表无法 CACHE 在内 存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。 
* MEMORY表通常用于更新不太频繁的小表,用以快速得到访问结果。

MERGE
* 用于将一系列等同的MyISAM表以逻辑方式组合在一起,并作为一个对象引用它们。
* MERGE表的优点在于可以突破对单个MyISAM表大小的限制，并且通过将不同的表分布在多个磁盘上，可以有效地改善MERGE表的访问效率。
* 这对于诸如数据仓储等 VLDB 环境十分适合。

## 面试问题

>MyISAM 和 InnoDB 区别
>
|方面|MyISAM|InnoDb|
|----|-----|-------|
|事务和外键|InnoDB支持事务和外键，具有安全性和完整性，适合大量insert或update操作|MyISAM不支持事务和外键，它提供高速存储和检索，适合大量的select查询操作|
|索引结构|InnoDB 是聚簇索引,索引和记录在一起存储，既缓存索引，也缓存记录。|MyISAM 是非聚簇索引,索引和记录分开|
|并发处理能力|InnoDB 最小的锁粒度是行锁,读写阻塞可以与隔离级别有关，可以采用多版本并发控制（MVCC）来支持高并发|MyISAM最小的锁粒度是表锁,会导致写操作并发率低，读之间并不阻塞，读写阻塞|
|存储文件|InnoDB表对应两个文件，一个.frm表结构文件，一个.ibd数据文件。InnoDB表最大支持64TB|MyISAM表对应三个文件，一个.frm表结构文件，一个MYD表数据文件，一个.MYI索引文件|

> 适用场景
MyISAM
 * 不需要事务支持（不支持）
 * 并发相对较低（锁定机制问题）数据修改相对较少，以读为主
 * 数据一致性要求不高
 
InnoDB
* 需要事务支持（具有较好的事务特性）
* 行级锁定对高并发有很好的适应能力
* 数据更新较为频繁的场景数据一致性
* 要求较高硬件设备内存较大，可以利用InnoDB较好的缓存能力来提高内存利用率，减少磁盘IO

* 索引结构:InnoDB 是聚簇索引，MyISAM 是非聚簇索引。
   * 聚簇索引的文件存放在主键索引的叶子节点上，因此InnoDB必须要有主键，通过主键索引效率很高。
   * 但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。
   * 主键不应该过大，因为主键太大，其他索引也都会很大。
   * MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

* 是否需要事务？有，InnoDB
* 是否存在并发修改？有，InnoDB
* 是否追求快速查询，且数据修改少？是，MyISAM
* 在绝大多数情况下，推荐使用InnoDB

> 一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？'
* 如果表的类型是MyISAM,那么是18.因为MyISAM表会把自增主键的最大ID 记录到数据文件中
* 如果表的类型是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID记录到内存中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失

> 哪个存储引擎执行`select count(*)`更快，为什么?
* MyISAM更快，因为MyISAM内部维护了一个计数器，可以直接调取。在 MyISAM 存储引擎中，把表的总行数存储在磁盘上，当执行`select count(*) from t`时,直接返回总数据。
* 在InnoDB存储引擎中，跟 MyISAM 不一样，没有将总行数存储在磁盘上，当执行 `select count(*) from t`时，会先把数据读出来，一行一行的累加，最后返回总数量。
* 为什么InnoDB引擎不像 MyISAM 引擎一样，将总行数存储到磁盘上？这跟 InnoDB 的事务特性有关，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。


---
# 索引

> 索引（Index）是帮助MySQL高效获取数据的数据结构

索引的本质是：数据结构
* 索引的目的在于提高查询效率
* 可以简单的理解为“排好序的快速查找数据结构”
* 数据本身之外，数据库还维护者一个满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据
* 这样就可以在这些数据结构上实现高级查找算法。
* 索引本身也很大，不可能全部存储在内存中，一般以索引文件的形式存储在磁盘

平常说的索引,没有特别指明的话,就是B+树（多路搜索树，不一定是二叉树）结构组织的索引. 其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引

MySQL 中还支持全文本(FULLTEXT)索引，该索引可以用于全文搜索。但是当前最新版 本中(5.0)只有 MyISAM 存储引擎支持 FULLTEXT 索引，并且只限于 CHAR、VARCHAR 和 TEXT 列。索引总是对整个列进行的，不支持局部(前缀)索引.

MEMORY 存储引擎使用 HASH 索引，但也支持 BTREE 索引。

基本语法: 
```
CREATE [UNIQUE] INDEX indexName ON mytable(username(length));
create index cityname on city (city(10));//要为 city 表创建了 10 个字节的前缀索引
ALTER table tableName ADD [UNIQUE] INDEX indexName(columnName);
ALTER TABLE tbl_name ADD PRIMARY KEY (column_list)// 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。
ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list) // 该语句指定了索引为 FULLTEXT ，用于全文索引。
drop index cityname on city;
SHOW INDEX FROM table_name\G  //可以通过添加 \G 来格式化输出信息。
```

优势
* 提高数据检索效率
* 降低数据库IO成本降低数据排序的成本
* 降低CPU的消耗

劣势
* 索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存
* 插入和更新操作会更改索引，因此会影响数据库插入和更新的性能，并且索引会占用一定的磁盘空间，使数据库变大
* 数据库中索引是以文件的方式存储的，需要用的时候读取到内存中，因此索引的I/O操作会影响数据库的性能

## MySQL索引分类

数据结构角度
* B+树索引
* Hash索引
* Full-Text全文索引
* R-Tree索引

从物理存储角度
* 聚集索引（clustered index）
* 非聚集索引（non-clustered index），也叫辅助索引(secondary index)聚集索引和非聚集索引都是B+树结构

从逻辑角度

* 主键索引：主键索引是一种特殊的唯一索引，不允许有空值
* 普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引
* 多列索引(复合索引、联合索引): 复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合
* 唯一索引或者非唯一索引空间索引
* 空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建


## MySQL索引结构
> 索引（index）是在存储引擎(storage engine)层面实现的，而不是server层面

系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的,位于同一个磁盘块中的数据会被一次性读取出来,而不是需要什么取什么

MySQL中的数据存储通常以Page为单位,俗称数据页
* 每个Page对应B+Tree的一个节点
* 页是InnoDB磁盘管理的最小单位,默认每个数据页的大小为16kb，也可以通过参数innodb_page_size将页的大小设置成其他值。
* 默认情况下一个Page的大小为16kb，由于每个Page中数据通过指针相连，且每个指针大小为6字节

```
我们通常使用长度为8个字节的bigint类型作为主键id的类型。
假设每条记录长度为1kb（包含指针）；
已知，每一条数据都会包含一个6字节的指针
所以一条索引数据大约占用8+6=14个字节,一个Page中能存储16 * 1024 / 14 ≈ 1170条索引数据
```

系统一个磁盘块的存储空间往往没有这么大,因此,InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB
* InnoDB在把磁盘数据读入到磁盘时会以页为基本单位


### B-Tree
> 为磁盘等外存储设备设计的一种平衡查找树

B-Tree 借助计算机磁盘预读机制;每次新建节点的时候,都是申请一个页的空间,所以每查找一个节点只需要一次 I/O,因为实际应用当中，节点深度会很少，所以查找效率很高。

* 在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。
* B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块

B-tree的node
* 一个二元组[key, data]
* key为记录的键值，对应表中的主键值
* data为一行记录中除主键外的数据.对于不同的记录,key值互不相同
* 每个节点占用一个盘块的磁盘空间
* 一个节点上有两个升序排序的关键字和三个指向子树根节点的指针
* 指针存储的是子节点所在磁盘块的地址

m阶的B-Tree的特性
* 根结点至少有两个子女
* 每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m 
* 每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m
* 所有的叶子结点都位于同一层
* 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划
* ki(i=1,…n)为关键字，且关键字升序排序
* Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)

### B+Tree索引

数据库中B+Tree的高度一般在2-4之间，即查找某一键值的行记录时最多进行2-4次IO

一个m阶的B+树具有如下几个特征：
* 有k个子树的中间节点包含有k个元素（B树中是k-1个元素）
* 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接
* 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素

B+Tree索引可以分为聚集索引(clustered index)和辅助索引(secondary index)
* 聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据
* 辅助索引的叶子节点并不包含行记录的全部数据,而是存储相应行数据的聚集索引键,即主键.当通过辅助索引来查询数据时.InnoDB会遍历辅助索引找到主键,然后再通过主键在聚集索引中找到完整的行记录数据



### 存储引擎与索引

MyISAM 和 InnoDB 存储引擎，都使用 B+Tree的数据结构
* 它相对与B-Tree结构，非叶子节点只存储键值信息, 所有的数据都存放在叶子节点上,所有叶子节点之间都有一个链指针.且把叶子节点通过指针连接到一起，形成了一条数据链表，以加快相邻数据的检索效率。
* 对B+Tree进行两种查找运算: 一种是对于主键的范围查找和分页查找,另一种是从根节点开始，进行随机查找.因为在B+Tree上有两个头指针,一个指向根节点,另一个指向关键字最小的叶子节点，所有叶子节点（即数据节点）之间是一种链式环结构
* MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作

MyISAM索引结构
* MyISAM存储引擎中数据文件和索引文件是分离的。
* MyISAM的索引主要分为主索引和辅助索引:MyISAM索引方式也称为“非聚集”索引
* 主索引（primary key）：以主键做为索引，因此key是唯一的
* 辅助索引（secondary key）：辅助索引以非主键做为索引，因此key是可以重复的


InnoDB索引结构
* nnoDB存储引擎也分为主索引和辅助索引：InnoDB索引方式也称为聚集索引
* InnoDB数据文件本身就是索引文件.因为InnoDB的数据文件本身是按主键聚集的,所以InnoDB要求表必须有主键,如果没有显示指定主键,InnoDB会自动选择可以唯一标识数据记录的列做主键;如果不存在,则表生成一个隐含字段作为主键



> 聚簇索引和非聚簇索引区别


> 为什么MySQL 索引中用B+tree，不用B-tree 或者其他树，

* 树的查询时间跟树的高度有关，B+树是一棵多路搜索树可以降低树的高度，提高查找效率
* MySQL并未使用红黑树作为索引的实现，主要原因在于红黑树只有两个子树,深度过大，数据检索时造成磁盘IO频繁
* B-Tree是一种自平衡的多叉搜索树，一个节点可以拥有两个以上的子节点,MySQL索引一般都存储在内存中,如果使用B-Tree作为索引的话,索引和数据存储在一块,一定内存的情况下可以存储的索引数量相对有限，毕竟每条数据的大小一般远大于索引列的大小，导致内存使用率不高.
* 而B-Tree和红黑树对于顺序查询并不友好，B+Tree的数据页只存储在叶子节点中，并且叶子节点之间通过指针相连，为双向链表结构,能够很好支持单值，范围查询，有序性查询
* B+树更适合外部存储(一般指磁盘存储),由于内节点(非叶子节点)不存储data,所以一个节点可以存储更多的内节点,每个节点能索引的范围更大更精确.也就是说使用B+树单次磁盘I/O的信息量相比较B树更大,I/O 效率更高。
* MySQL会按照区间来访问某个索引列,B+树的叶子节点间按顺序建立了链指针,加强了区间访问性,所以 B+树对索引列上的区间范围查询很友好.而B树每个节点的key和data在一起,无法进行区间查找


> 既然增加树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优的查找效率？

* 这样会形成一个有序数组，文件系统和数据库的索引都是存在硬盘上的,并且如果数据量大的话,不一定能一次性加载到内存中。
* 这时候B+树的多路存储，可以每次加载B+树的一个结点，然后一步步往下找

>  为什么不用Hash索引，聚簇索引/非聚簇索引，

* 哈希结构在单条数据的等值查询是性能非常优秀，但是只能用来搜索等值的查询
* Hash索引通常都是随机的内存访问，对于缓存不友好
* Hash 索引无法被用来避免数据的排序操作
* Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B+Tree索引高
 



> MySQL 索引底层实现，叶子结点存放的是数据还是指向数据的内存地址，
> 
> 使用索引需要注意的几个地方？使用索引查询一定能提高查询的性能吗？为什么?


## 设计索引的原则
* 在经常需要搜索的列上，可以加快搜索的速度.搜索的索引列,不一定是所要选择的列. 换句话说, 最适合索引的列是出现在WHERE子句中的列或连接子句中指定的列,而不是出现在 SELECT 关键字后的选择列表中的列
* 使用惟一索引。考虑某列中值的分布。索引的列的基数越大，索引的效果越好.例如生日和性别
* 使用短索引.如果对字符串列进行索引,应该指定一个前缀长度,过长的字段会使索引的数据结构变大，占用更多的空间，因此影响数据库的性能
 * 如果有一个 CHAR(200)列，如果在前 10 个或 20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。
 * 较小的索引涉及的磁盘 IO 较少，较短的值比较起来更快
 * 对于较短的键值,,索引高速缓存中的块能容纳更多的键值,因此,MySQL 也可以在内存中容纳更多的值。这样就增加了找到行而不用读取索引中较多块的可能性
* 利用最左前缀.在创建一个n列的索引时,实际是创建了MySQL可利用的n个索引.多列索引可起几个索引的作用,因为可利用索引中最左边的列集来匹配行.这样的列集称为最左前缀。
* 不要过度索引。不要以为索引“越多越好”，什么东西都用索引是错误的。
  * 每个额外的索引都要占用额外的磁盘空间,并降低写操作的性能
  * 在修改表的内容时，索引必须进行更新，有时可能需要重构，因此，索引越多，所花的时间越长
  * 如果有一个索引很少利用或从不使用，那么会不必要地减缓表的修改速度
* 在数据库中尽量使用单调增的字段做为主键，因为索引本身是一个B+树，如果字段是非单调增的，则插入操作会频繁的分裂B+树来调增数据的有序性和平衡性
* 对于 InnoDB 存储引擎的表，记录默认会按照一定的顺序保存如果有明确定义的主键，则按照主键顺序保存.如果没有主键，但是有唯一索引，那么就是按照唯一索引的顺序保存
  *  InnoDB表的普通索引都会保存主键的键值,所以主键要尽可能选择较短的数据类型,可以有效地减少索引的磁盘占用，提高索引的缓存效果。


---
# 事务
> 事务(Transaction)是访问和更新数据库的程序执行单元:事务中可能包含一个或多个sql语句，这些语句要么都执行，要么都不执行

MySQL中服务器层不管理事务,事务是由存储引擎实现的
典型的MySQL事务是如下操作的：
```
start transaction;
sql；
sql;
sql;
commit;
```
如果sql语句执行出现问题，会调用rollback，回滚所有已经执行成功的sql语句。当然，也可以在事务中直接使用rollback语句进行回滚
* 事务也是在存储引擎层实现的

## 数据库事务的四个特性 ACID
> 按照严格的标准，只有同时满足ACID特性才是事务；但是在各大数据库厂商的实现中，真正满足ACID的事务少之又少

* Atomicity 原子性整个事务中的所有操作,要么全部完成,要么全部不完成,不可能停滞在中间某个环节.事务在执行过程中发生错误.会被Rollback到事务开始前的状态，就像这个事务从来没有执行过一样
* Consistency：在事务开始之前和事务结束以后,数据库的完整性约束没有被破坏
* Isolation:一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的,并发执行的各个事务之间不能互相干扰
* Durability持久性：在事务完成以后,该事务所对数据库所作的更改便持久的保存在数据库之中,并不会被回滚

## 并发事务处理带来的问题
* 更新丢失(Lost Update):事务A和事务B选择同一行，然后基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，就会发生丢失更新问题
* 脏读(Dirty Read):一个事务读到了另一个未提交事务修改过的数据
* 不可重复读(Non-Repeatable Read):事务A多次读取同一数据,事务B在事务A多次读取的过程中,对数据作了更新并提交，导致事务A多次读取同一数据时,结果不一致
* 幻读(Phantom):一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来

幻读和不可重复读的区别：
* 不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样
* 幻读的重点在于新增或者删除：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样

并发事务处理带来的问题的解决办法：
* 需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任
* 脏读”,“不可重复读”和“幻读”,其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决
 * 一种是加锁:在读取数据前，对其加锁，阻止其他事务对数据进行修改。
 * 另一种是数据多版本并发控制（MultiVersion Concurrency Control，简称 MVCC 或 MCC)：不用加任何锁,通过一定机制生成一个数据请求时间点的一致性数据快照(Snapshot),并用这个快照来提供一定级别 (语句级或事务级)的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本

## 事务隔离级别
> 事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的
```
show variables like 'tx_isolation'
```
* READ-UNCOMMITTED(读未提交)：最低的隔离级别，事务A可以读取到事务B修改过但未提交的数据，可能会导致脏读、幻读或不可重复读。
* READ-COMMITTED(读已提交)：事务B只能在事务A修改过并且已提交后才能读取到事务B修改的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
* REPEATABLE-READ(可重复读)：就是在开始读取数据(事务开启)时，不再允许修改操作，可以阻止脏读和不可重复读，但幻读仍有可能发生。
* SERIALIZABLE(可串行化)：最高的隔离级别，完全服从ACID的隔离级别。会在读取的每一行数据上都加锁,所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰

MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）
* InnoDB 存储引擎在 REPEATABLE-READ（可重读） 事务隔离级别下使用的是Next-Key Lock 算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的

## MVCC 多版本并发控制
> 通过保存数据在某个时间点的快照来实现并发控制的，不管事务执行多长时间，事务内部看到的数据是不受其它事务影响的

### MVCC解决什么问题？
* 通过 MVCC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力
* 因为 InnoDB 的 MVCC 采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行
* 一致性读也被称为快照读，当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果

典型的MVCC实现方式
* 乐观（optimistic）并发控
* 悲观（pressimistic）并发控制

InnoDB 的 MVCC
* 是通过在每行记录后面保存两个隐藏的列来实现一个保存了行的创建时间 一个保存行的过期时间（删除时间）存储的并不是真实的时间，而是系统版本号(system version number)
* 每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较

### REPEATABLE READ隔离级别下MVCC如何工作
* SELECT：InnoDB会根据以下两个条件检查每行记录：
  * InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在开始事务之前已经存在要么是事务自身插入或者修改过的
  * 行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除
  * 只有符合上述两个条件的才会被查询出来
  
* INSERT：InnoDB为新插入的每一行保存当前系统版本号作为行版本号
* DELETE：InnoDB为删除的每一行保存当前系统版本号作为行删除标识
* UPDATE：InnoDB为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识

MVCC 只在 COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作

## 事务日志
> MySQL的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等

InnoDB存储引擎还提供了两种事务日志：
* redo log(重做日志). 用于保证事务持久性
* undo log(回滚日志). 是事务原子性和隔离性实现的基础。

InnoDB实现回滚靠的是undolog
* 当事务对数据库进行修改时，InnoDB会生成对应的undo log；
* 如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息,根据undo log的内容做与之前相反的工作,将数据回滚到修改之前的样子

### 事务的实现
> 事务的实现就是如何实现ACID特性。
* 事务的隔离性是通过锁实现或MVCC实现的
* 而事务的原子性、一致性和持久性则是通过事务日志实现 。

事务日志包括：重做日志redo和回滚日志undo

#### redo log
> 用于保证事务持久性
该日志文件由两部分组成：
* 重做日志缓冲（redo log buffer）
* 重做日志文件（redo log）,前者是在内存中，后者在磁盘中

事务中的操作,都会先写入存储引擎的日志缓冲中,在事务提交之前,这些缓冲的日志都需要提前刷新到磁盘上持久化，这就是DBA们口中常说的“日志先行”(Write-Ahead Logging)

#### undo log
> 实现一致性, undo log 主要为事务的回滚服务
在事务执行的过程中
* 除了记录redo log，还会记录一定量的undo log。
* undo log记录了数据在每个操作前的状态，
* 如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作
* Undo记录的是已部分完成并且写入硬盘的未完成的事务，默认情况下回滚日志是记录下表空间中的

不同
* redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。
* 二者记录的内容也不同，redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录


> Mysql怎么保证一致性的？

从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。
* 也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性
* 数据库必须要实现AID三大特性，才有可能实现一致性

如果你在事务里故意写出违反约束的代码，一致性还是无法保证的
* 因此，还必须从应用层角度考虑。通过代码判断数据库数据是否有效，然后决定回滚还是提交数据

> Mysql怎么保证原子性的？

是利用Innodb的undo log。
* undo log属于逻辑日志，它记录的是sql执行相关的信息
* 当事务对数据库进行修改时，InnoDB会生成对应的undo log；
* 如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。

> Mysql怎么保证持久性的？

利用Innodb的redo log
* 当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作
* 当事务提交的时候，会将redo log日志进行刷盘
* 当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中
* 再根据undo log和binlog内容决定回滚数据还是提交数据。


> Mysql怎么保证隔离性的？

利用的是锁和MVCC机制
* MVCC,一个行记录数据有多个版本对快照数据，这些快照数据在undo log中

> 你知道MySQL 有多少种日志吗？
* 错误日志：记录出错信息，也记录一些警告信息或者正确的信息。
* 查询日志：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。
* 慢查询日志：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。
* 二进制日志：记录对数据库执行更改的所有操作。
* 中继日志：中继日志也是二进制日志，用来给slave 
* 库恢复事务日志：重做日志redo和回滚日志undo

### MySQL对分布式事务的支持

InnoDB 提供的原生的事务支持
* 开始支持XA协议的分布式事务
* 一个分布式事务会涉及多个行动，这些行动本身是事务性的。
* 所有行动都必须一起成功完成，或者一起被回滚。

#### 分布式事务架构
> 使用分布式事务涉及一个或多个资源管理器和一个事务管理器

模型中分三块：应用程序（AP）、资源管理器（RM）、事务管理器（TM）:
* 应用程序：定义了事务的边界，指定需要做哪些事务；
* 资源管理器：提供了访问事务的方法，通常一个数据库就是一个资源管理器
* 事务管理器：协调参与了全局事务中的各个事务

![image](https://user-images.githubusercontent.com/27160394/140637721-06497e48-078b-46e8-b513-ce3810565afe.png)

分布式事务采用两段式提交（two-phase commit）的方式：
* 第一阶段所有的事务节点开始准备，告诉事务管理器ready。
* 第二阶段事务管理器告诉每个节点是commit还是rollback。如果有一个节点失败，就需要全局的节点全部rollback，以此保障事务的原子性

----

# MySQL锁机制
> 数据库锁定机制是数据库为了保证数据的一致性，而使各种共享资源在被并发访问变得有序所设计的一种规则

理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取，检查，释放锁等动作），因此数据库系统需要在高并发响应和系统性能两方面进行平衡

从对数据操作的类型分类：
* 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行，不会互相影响
* 写锁（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁

从对数据操作的粒度分类：
* 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低（MyISAM 和 MEMORY 存储引擎采用的是表级锁
* 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB 存储引擎既支持行级锁也支持表级锁，但默认情况下是采用行级锁）；
* 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

## MyISAM表锁
* 表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；
* 表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；

## InnoDB 行锁
* 共享锁（S）：多个事务对于同一数据可以共享一把锁m都能访问到数据,但是只能读不能修改.阻止其他事务获得相同数据集的排他锁。
* 排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁

为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁
* 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。
* 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁

## 加锁机制
乐观锁与悲观锁是两种并发控制的思想，可用于解决丢失更新问题
* 乐观锁会“乐观地”假定大概率不会发生并发更新冲突，访问、处理数据过程中不加锁，只在更新数据时再根据版本号或时间戳判断是否有冲突，有则处理，无则提交事务.用数据版本（Version）记录机制实现
* 悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、处理数据前就加排他锁，在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁
 * 悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了
 
锁模式(InnoDB有三种行锁的算法)
* 记录锁(Record Locks)：单个行记录上的锁。对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项
* 间隙锁(Gap Locks):当我们使用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁。对于键值在条件范围内但并不存在的记录，叫做“间隙”
 * 对索引项之间的“间隙”加锁，锁定记录的范围,使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据
 * GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况
* 临键锁(Next-key Locks)：是记录锁与间隙锁的组合,它的封锁范围既包含索引记录又包含索引区间.(临键锁的主要目的，也是为了避免幻读(Phantom Read).如果把事务的隔离级别降级为RC，临键锁则也会失效。)

> select for update有什么含义，会锁表还是锁行还是其他
* for update 仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。
* 在进行事务操作时，通过“for update”语句，MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁


InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！


## 死锁
死锁产生
* 死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环当
* 事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁。
* 锁的行为和顺序和存储引擎相关，以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。

检测死锁：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误

死锁恢复：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，
* InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可

外部锁的死锁检测
* 发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。
* 但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁,这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决


MyISAM避免死锁：
* 在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，所以 MyISAM 表不会出现死锁。

InnoDB避免死锁：
* 为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用SELECT ... FOR UPDATE语句来获取必要的锁
* 在事务中,如果要更新记录,应该直接申请足够级别的锁,即排他锁,而不应先申请共享锁.更新时再申请排他锁,因为这时候当用户再申请排他锁时,其他事务可能又已经获得了相同记录的共享锁,从而造成锁冲突,甚至死锁
* 如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会
* 改变事务隔离级别
* 可以用 show engine innodb status;命令来确定最后一个死锁产生的原因
----
# MySQL调优
## 性能分析
MySQL常见性能分析手段
* 慢查询日志
* EXPLAIN 分析查询
* profiling分析
* show命令查询系统状态及系统变量


### 性能瓶颈定位
* 通过 show 命令查看 MySQL 状态及变量，找到系统的瓶颈
```
Mysql> show status ——显示状态信息（扩展show status like ‘XXX’）

Mysql> show variables ——显示系统变量（扩展show variables like ‘XXX’）

Mysql> show innodb status ——显示InnoDB存储引擎的状态

Mysql> show processlist ——查看当前SQL执行，包括执行状态、是否锁表等

Shell> mysqladmin variables -u username -p password——显示系统变量

Shell> mysqladmin extended-status -u username -p password——显示状态信息
```

### Explain(执行计划)
> 使用 Explain 关键字可以模拟优化器执行SQL查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈

执行计划包含的信息（如果有分区表的话还会有partitions）

![image](https://user-images.githubusercontent.com/27160394/140641340-525b1246-9606-47e6-949f-e1449a037f42.png)

* `id`:select查询的序列号,表示查询中执行select子句或操作表的顺序
 * id相同，执行顺序从上往下
 * id全不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
 * id部分相同，执行顺序是先按照数字大的先执行，然后数字相同的按照从上往下的顺序执行
* `select_type`:查询的类型，主要是用于区分普通查询、联合查询、子查询等复杂的查询
 * SIMPLE ：简单的select查询，查询中不包含子查询或UNION
 * PRIMARY：查询中若包含任何复杂的子部分，最外层查询被标记为PRIMARY
 * SUBQUERY：在select或where列表中包含了子查询
 * DERIVED：在from列表中包含的子查询被标记为derived（衍生）
 *  UNION：若第二个select出现在union之后
 *  UNION RESULT：从union表获取结果的select
* type 访问类型: 从最好到最差依次排列system>const>eq_ref>ref>fulltext>ref_or_null>index_merge >unique_subquery>index_subquery>range>index>ALL
  * system：表只有一行记录（等于系统表），是 const 类型的特例，平时不会出现
  * const：表示通过索引一次就找到了,const用于比较primary key 或 unique 索引
  * range：只检索给定范围的行，使用一个索引来选择行
  * index：Full Index Scan，index于ALL区别为index类型只遍历索引树。通常比ALL快
  * ALL：Full Table Scan，将遍历全表找到匹配的行
* key: 实际使用的索引，如果为NULL，则没有使用索引
* key_len表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度
* ref: 显示索引的那一列被使用了，如果可能，是一个常量const

### 慢查询日志
> MySQL 提供的一种日志记录，它用来记录在 MySQL 中响应时间超过阈值的语句，具体指运行时间超过 long_query_time 值的 SQL，则会被记录到慢查询日志中

* long_query_time 的默认值为10，意思是运行10秒以上的语句
* 默认情况下，MySQL数据库没有开启慢查询日志，需要手动设置参数开启

```
SHOW VARIABLES LIKE '%slow_query_log%'
mysql> set global slow_query_log='ON';
mysql> set global slow_query_log_file='/var/lib/mysql/hostname-slow.log';
mysql> set global long_query_time=2;

```
MySQL提供了日志分析工具mysqldumpslow,通过 mysqldumpslow --help 查看操作帮助信息
```

```

### Show Profile 分析查询
> Show Profile命令查看执行状态
* Show Profile 是 MySQL 提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量
* 默认情况下，参数处于关闭状态，并保存最近15次的运行结果
* 开启功能，默认是关闭，使用前需要开启 mysql>set profiling=1;
* 运行SQL
* 查看结果

## 性能优化

索引优化
1. 全值匹配我最爱
2. 最佳左前缀法则，比如建立了一个联合索引(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)
3. 不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描
4. 存储引擎不能使用索引中范围条件右边的列
5. 尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select is null ,is not null 也无法使用索引
6. like "xxxx%" 是可以用到索引的，like "%xxxx" 则不行(like "%xxx%" 同理)。like以通配符开头('%abc...')索引失效会变成全表扫描的操作，
7. 字符串不加单引号索引失效
8. 少用or，用它来连接时会索引失效
9. <，<=，=，>，>=，BETWEEN，IN 可用到索引，<>，not in ，!= 则不行，会导致全表扫描
10. 在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好
11. 在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引


查询优化

数据类型优化

----




