* What is index
* Why use idex
* Index internal structure
* How index works
* Index category
* Indexs in storage engine
* How to design index
* Notes
----

#  What is 索引
> 索引(Index)是一种单独的,物理的对数据库表中一列或多列的值进行排序的一种存储结构,它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单.

索引的本质是：数据结构
* 索引的目的在于提高查询效率,可以简单的理解为“排好序的快速查找数据结构”, 这样就可以在这些数据结构上实现高级查找算法。
* 快速找出在某个或多个列中有一特定值的行
* 数据本身之外，数据库还维护者一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据

## 索引的物理存储

索引本身也很大，不可能全部存储在内存中，一般以索引文件的形式存储在磁盘

> For the MyISAM engine,,a table's indexes are stored in the `.MYI file` 
* MyISAM索引文件和数据文件是分离的,采用非聚簇索引-MyISAM `myi`索引文件和`myd`数据文件分离.MyISAM的索引文件仅仅保存数据记录的地址
* MyISAM的索引文件仅仅保存数据记录的地址.如果指定的Key存在，则取出其data域的值，然后以data域的值为指针地址，读取相应数据记录.

> For InnoDB engine, the indexes are stored in the tablespace, along with the table. If innodb_file_per_table option is set, the indexes will be in the table's `.ibd`

* InnoDB的数据文件本身就是索引文件，叶节点data域保存了完整的数据记录.
* 这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这种索引叫做“聚焦索引”
* InnoDB的辅助索引的data域存储相应记录主键的值而不是地址,InnoDB的所有辅助索引都引用主键作为data域。

在InnoDB 存储引擎中,所有的数据都被逻辑地存放在表空间中

<img width="407" alt="Screen Shot 2021-11-10 at 5 43 12 PM" src="https://user-images.githubusercontent.com/27160394/141089357-0a4c4352-a8d6-4483-8718-e1b541332f11.png">


* 表空间(`ibd`)是存储引擎中最高的存储逻辑单位,在表空间的下面又包括段(segment),区(extent),页(page)
 * 独享表空间存储方式使用`.ibd`文件，并且每个表一个`ibd`文件；
 * 共享表空间存储方式使用`.ibdata`文件，所有表共同使用一个`ibdata`文件； 
* 每个Tablespace 包含多个Segment段
* 每个段(分为2种段：叶子节点Segment&非叶子节点Segment)
* 一个Segment段包含多个Extent，一个Extent占用1M空间包含64个Page（每个Page 16k）
* 每个索引一个B+树,一个B+树节点 = 一个物理Page（16K）
* 一个Page里包含很多有序数据Row行数据，Row行数据中包含Fields属性数据等信息

Note:
* 由于InnoDB采用聚簇索引结构存储,索引InnoDB的数据文件需要按照主键聚集,因此InnoDB要求表必须有主键(MyISAM可以没有)
* 如果没有指定Mysql会自动选择一个可以唯一表示数据记录的列作为主键
* 如果不存在这样的列,Mysql自动为InnoDB表生成一个隐含字段(6个字节长整型)作为主键。 
* InnoDB的所有辅助索引都引用数据记录的主键作为data域。

聚簇索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得数据记录主键，然后用主键到主索引中检索获得数据记录。

> MEMORY 存储引擎使用 HASH 索引，但也支持 BTREE 索引。

## 磁盘存取原理
> 索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操

![image](https://user-images.githubusercontent.com/27160394/141095292-13b3185a-7587-45ad-9e9c-05014f021d28.png)

* 磁道(track):每个同心环叫做一个
* 扇区(sector): 磁盘的最小存储单元
* 当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘
* 磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区
* 为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道
* 然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间

预读
* 磁盘往往不是严格按需读取,而是每次都会预读
* 即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。
* 预读可以提高I/O效率。预读的长度一般为页的整倍
* 主存和磁盘以页为单位交换数据
* 当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中


## 基本语法: 
```
CREATE [UNIQUE] INDEX indexName ON mytable(username(length));
create index cityname on city (city(10));//要为 city 表创建了 10 个字节的前缀索引
ALTER table tableName ADD [UNIQUE] INDEX indexName(columnName);
ALTER TABLE tbl_name ADD PRIMARY KEY (column_list)// 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。
ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list) // 该语句指定了索引为 FULLTEXT ，用于全文索引。
drop index cityname on city;
SHOW INDEX FROM table_name\G  //可以通过添加 \G 来格式化输出信息。
```
---
# Why use idex
当表中有大量记录时，若要对表进行查询
1. 全表搜索，是将所有记录一一取出,和查询条件进行一一对比，然后返回满足条件的记录
  * 这样做会消耗大量数据库系统时间
  * 并造成大量磁盘 I/O 操作
  
<img width="371" alt="Screen Shot 2021-11-10 at 6 43 58 PM" src="https://user-images.githubusercontent.com/27160394/141099033-b86b03d3-38a6-46ff-a408-00395443ddfb.png">

2. 在表中建立索引，然后在索引中找到符合查询条件的索引值,快速找到表中对应的记录

<img width="402" alt="Screen Shot 2021-11-10 at 6 44 50 PM" src="https://user-images.githubusercontent.com/27160394/141099159-15f72bac-056d-4dfd-a803-3f85fbebb82c.png">


优势
* 索引大大减小了服务器需要扫描的数据量,降低数据库IO成本降低数据排序的成本提高数据检索效率 
* 被索引的列会⾃动进⾏排序，降低数据排序的成本降低了CPU的小号
* 索引可以帮助服务器避免排序和临时表。

劣势
* 建立索引会占用磁盘空间的索引文件。一般情况这个问题不算严重，但如果你在一个大表上创建了多种组合索引，且伴随大量数据量插入，索引文件大小也会快速膨胀。
* 索引需要动态的维护，当对表中的数据进行增加、删除、修改时，会降低数据的维护速度(索引会出现一些碎片)

---
# MySQL索引数据结构
> 索引（index）是在存储引擎(storage engine)层面实现的，而不是server层面

## B-Tree
> 有序数组+平衡多叉树

<img width="551" alt="Screen Shot 2021-11-10 at 7 43 05 PM" src="https://user-images.githubusercontent.com/27160394/141107111-0a8a8d4d-69c8-4f7e-8944-e0e2f7cc7db3.png">


B-Tree 借助计算机磁盘预读机制;每次新建节点的时候,都是申请一个页的空间,所以每查找一个节点只需要一次 I/O,因为实际应用当中,节点深度会很少,所以查找效率很高。
* 在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。
* B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块

B-tree 特点
* 他会将数据也保存在非页子节点 -> 这个特点会导致非页子节点不能存储大量的索引
* 搜索有可能在非叶子节点结束
* 在关键字全集内做一次查找，性能逼近二分查找算法


B-tree的node
* 每个节点中不仅包含数据的key值，还有data值,一个二元组[key, data]
 * key为记录的键值，对应表中的主键值
 * data为一行记录中除主键外的数据.对于不同的记录,key值互不相同
* 每个节点占用一个盘块的磁盘空间
* 指针存储的是子节点所在磁盘块的地址

m阶的B-Tree的结构
* 根结点至少有两个子女
* 每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m 
* 每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m
* 所有的叶子结点都位于同一层
* 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划
* ki(i=1,…n)为关键字，且关键字升序排序
* Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)

## B+Tree索引
> 有序数组链表+平衡多叉树

![image](https://user-images.githubusercontent.com/27160394/141110026-4d1edec2-964c-4da9-b302-8be09bc35494.png)

> B+Tree 特点
* 非叶子节点只存储键值信息(非页子节点能存储大量的简直)
* 所有叶子节点之间都有一个链指针，数据记录都存放在叶子节点中
* 通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点
* B+树的最大元素始终位于根节点当中


> 一个m阶的B+树具有如下几个特征：
* 有k个子树的中间节点包含有k个元素（B树中是k-1个元素）
* 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接
* 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素

> B+Tree索引可以分为聚集索引(clustered index)和辅助索引(secondary index)
* 聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据
* 辅助索引的叶子节点并不包含行记录的全部数据,而是存储相应行数据的聚集索引键,即主键.当通过辅助索引来查询数据时.InnoDB会遍历辅助索引找到主键,然后再通过主键在聚集索引中找到完整的行记录数据

> B+树的优势：
* 单一节点存储更多的元素，使得查询的IO次数更少。
* 所有查询都要查找到叶子节点，查询性能稳定。
* 所有叶子节点形成有序链表，便于范围查询。


Notes
* 应该尽量选择空间占用小的字段作为key，因为字段空间小，所以每一个B+树节点所包含的key就多了，高度就相对变小了
* 最好是自增的字段作为key,考虑非自增字段
  * 插入数据时,极有可能会插入到中间某个节点上,从而导致key进行节点调整,进而导致一系列的从磁盘读写page的操作,极大地增加了磁盘IO次数
  * 用自增字段，那最多只会新加一个page,将该数据放入再写回磁盘

### 数据定位过程

1. 索引精确查找: 确定定位条件, 找到根节点Page No, 根节点读到内存, 逐层向下查找, 读取叶子节点Page,通过 二分查找找到记录或未命中
![image](https://user-images.githubusercontent.com/27160394/141100751-ae4f744e-c2c6-43dd-b970-b15517ad5a2a.png)

2. 索引范围查找 : 读取根节点至内存, 确定索引定位条件id=18, 找到满足条件第一个叶节点, 顺序扫描所有结果, 直到终止条件满足id >=22。
![image](https://user-images.githubusercontent.com/27160394/141100844-a34ee86d-2ccf-4349-bef6-7f319581a8a8.png)

3. 全表扫描 : 直接读取叶节点头结点， 顺序扫描， 返回符合条件记录， 到最终节点结束
![image](https://user-images.githubusercontent.com/27160394/141101227-84f85350-01e4-4e48-bf90-078e213af726.png)

4.二级索引查找 : 通过二级索引查出对应主键，拿主键回表查主键索引得到数据， 二级索引可筛选掉大量无效记录，提高效
![Screen Shot 2021-11-10 at 7 01 39 PM](https://user-images.githubusercontent.com/27160394/141101539-9ff3eb85-4408-4bfa-860d-9b64dcbc45b6.png)


### B+Tree VS B Tree
* B+树更适合外部存储（一般指磁盘存储），由于内节点（非叶子节点）不存储 data，所以一个节点可以存储更多的内节点，每个节点能索引的范围更大更精确。也就是说使用 B+树单次磁盘 I/O 的信息量相比较 B 树更大，I/O 效率更高
* 经常会按照区间来访问某个索引列，B+树的叶子节点间按顺序建立了链指针，加强了区间访问性，所以 B+树对索引列上的区间范围查询很友好。而 B 树每个节点的 key 和 data 在一起，无法进行区间查找
* B+树还有一个最大的好处,方便扫库,B树必须用中序遍历的方法按序扫库,而B+树直接从叶子结点挨个扫一遍就完了,B+树支持range-query非常方便,而B树不支持。这是数据库选用B+树的最主要原因。
* B树的优势是当你要查找的值恰好处在一个非叶子节点时，查找到该节点就会成功并结束查询(有很多基于频率的搜索是选用B树),而B+树由于非叶节点只是索引部分，这些节点中只含有其子树中的最大(或最小)关键字，当非终端节点上的关键字等于给点值时，查找并不终止，而是继续向下直到叶子节点。 因此在B+树中，无论查找成功与否，都是走了一条从根到叶子节点的路径
---
# MySQL索引分类

## 数据结构角度
* B+树索引
* Hash索引
* Full-Text全文索引(关键字的匹配)
* R-Tree索引

### 从物理存储角度

* 聚簇索引(clustered index)
  * 聚簇索引根据主键来构建，叶子节点存放的是该主键对应的这一行记录,数据存储与索引放到了一块，找到索引也就找到了数据
  * 每个叶子节点存储了一行完整的表数据，叶子节点间按id列递增连接，可以方便地进行顺序检索(通常说的主键索引就是聚集索引)
* 非聚集索引（non-clustered index):
  * 将数据存储于索引分开结构，叶节点的data域存放的是数据记录的地址
  * 叶子节点存放的是这一行记录对应的主键的值
* 聚集索引和非聚集索引都是B+树结构
* InnoDB主键使用的是聚簇索引, MyISAM不管是主键索引, 还是二级索引使用的都是非聚簇索引

![image](https://user-images.githubusercontent.com/27160394/141118860-dbb77646-63e6-45e8-b486-3c77af7a86fc.png)


聚簇索引的优缺点
* 可以把相关数据存储在一起，减少数据查询时的磁盘I/O
* 数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快
* 使用索引覆盖的查询时可以直接使用页节点中的主键值
* 聚簇索引对于主键的排序查找和范围查找速度非常快
* 插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂
* 更新聚簇索引列的代价很高，因为会强制InnoDB把更新的列移动到新的位置,可能会导致“页分裂”


InnoDB的表要求必须要有聚簇索引：
1. 如果表定义了主键，则主键索引就是聚簇索引
2. 如果表没有定义主键，则第一个非空unique列作为聚簇索引
3. 否则InnoDB会从建一个隐藏的row-id作为聚簇索引

*为什么主键通常建议使用自增id*
* 聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的
* 如果主键不是自增id,那么可以想象,不断地调整数据的物理地址、分页


> 回表查询
由于二级索引的叶子节点不存储完整的表数据，索引当通过二级索引查询到聚簇索引列值后，还需要回到聚簇索引也就是表数据本身进一步获取数据。

1. 先通过普通索引定位到主键值
2. 在通过聚集索引定位到行记录；

> 查询覆盖
何为索引覆盖，就是在用这个索引查询时，使它的索引树，查询到的叶子节点上的数据可以覆盖到你查询的所有字段，这样就可以避免回表
```
alter table users create index on Name;
select ID,  Name from users where Name = "张三"; 
```
### 从逻辑角度
* 主键索引(Primary Key):InnoDB存储引擎的表会存在主键(唯一非null);主键索引是一种特殊的唯一索引，不允许有空值
* Unique(唯一索引):索引列的值必须唯一，但允许有空值。若是组合索引，则列值的组合必须唯一。
* 单列索引：单列索引即一个索引只包含单个列
* 组合索引(composite indexes)：组合索引指在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。使用组合索引时遵循最左前缀集合
* Key（普通索引）：是MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值
* FULLTEXT(全文索引):全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR或者TEXT类型的列上创建
* 空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建

> Full-Text全文索引
解决判断字段是否包含的问题(`MATCH (title,body) AGAINST`)
* `fulltext`索引仅可用于 MyISAM 表
* 全文索引，仅对类型为 CHAR/VARCHAR/TEXT 的字段生效
* 在生成这种类型的索引时，MySQL将把在文本中出现的所有单词创建为一份清单，查询操作将根据这份清单去检索有关的数据记录
* 如果查询字符串的长度过短将无法得到期望的搜索结果。MySql全文索引所能找到的词默认最小长度为4个字符
* 全文索引创建速度慢，而且对有全文索引的各种数据修改操作也慢


> 最左前缀原则
* 在检索数据时从联合索引的最左边开始匹配
* B+树的节点存储索引顺序是从左向右存储，在匹配的时候自然也要满足从左向右匹配
* 如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到
* 可以看到a的值是有顺序的，而b的值是没有顺序的,但是我们又可发现a在等值的情况下，b值又是按顺序排列的，但是这种顺序是相对的
* MySQL创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序
* 由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDER BY子句也遵循此规则


> 索引下堆(ICP)
* 如果不使用 ICP，存储引擎首先将通过索引定位到的行全部返回给 MySQL 服务端，服务端再通过 where 条件筛选符合条件的数据 
* 开启 ICP 后，如果部分where条件可以通过索引中的列来筛选，则 MySQL 服务端会将这些 where 条件下推到存储引擎，存储引擎会通过索引对这些条件进行筛选，最后返回符合条件的行
* ICP 可以降低MySQL服务端访问存储引擎的次数，也可以降低存储引擎访问数据表的次数

 ICP 应用场景
 * 当需要访问完整的行时，ICP 适用于 eq_ref、ref、ref_of_null、range 这四种访问方式
 * eq_ref：从表中读取一行（如果是联表查询，则是从各个表的笛卡尔积的结果中读取一行
 * ref：与索引值相匹配的所有的行都会被读出
 * ref_or_null：在 ref 的基础上，还对包含 NULL 的情况进行了查询
 * range：值在一定范围内的行会被读取

为什么要使用联合索引
* 减少开销.建一个联合索引 (col1,col2,col3)，实际相当于建了 (col1)，(col1,col2)，(col1,col2,col3) 三个索引
* 覆盖索引.对联合索引 (col1,col2,col3)，如果有如下的 SQL：select col1,col2,col3 from test where col1=1 and col2=2;。那么 MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机 IO 操作
* 效率高.索引列越多，通过索引筛选出的数据越少
---
# MySQL索引实现
索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的

## MyISAM索引实现
* MyISAM引擎使用B+Tree作为索引结构
* MyISAM的索引方式索引和数据存放是分开的，非聚集”的，所以也叫做非聚集索引
* 叶节点的data域存放的是数据记录的地址
* MyISAM的索引方式也叫做“非聚集”的
* 在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复
* 如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。
* 辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录

![image](https://user-images.githubusercontent.com/27160394/141402637-752c163f-5de8-497c-9a27-e418ce5d7350.png)



## InnoDB索引实现
* InnoDB也使用B+Tree作为索引结构
* InnoDB的数据文件本身就是索引文件
* 表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录,InnoDB表数据文件本身就是主索引
* 叶节点包含了完整的数据记录。这种索引叫做聚集索引
* InnoDB的二级索引的叶子节点存储的不是行号（行指针），而是主键列
* 这种策略的缺点是二级索引需要两次索引查找，第一次在二级索引中查找主键，第二次在聚簇索引中通过主键查找需要的数据行

---
## 索引建立原则

1. 列的离散型: 在条件表达式中经常用到的不同值较多的列上建立索引，在不同值很少的列上不要建立索引
2. 最左匹配原则 : 利用最左前缀。在创建一个n列的索引时，实际是创建了MySQL可利用的n个索引
3. 最少空间原则 : 当关键字占用的空间越小，则每个节点保存的关键字个数就越多，每次加载进内存的关键字个数就越多，检索效率就越高
4. 不要过度索引。不要以为索引“越多越好”，什么东西都用索引是错误的。
  * 每个额外的索引都要占用额外的磁盘空间,并降低写操作的性能
  * 在修改表的内容时，索引必须进行更新，有时可能需要重构，因此，索引越多，所花的时间越长
  * 如果有一个索引很少利用或从不使用，那么会不必要地减缓表的修改速度
6. 在数据库中尽量使用单调增的字段做为主键，因为索引本身是一个B+树，如果字段是非单调增的，则插入操作会频繁的分裂B+树来调增数据的有序性和平衡性
7. 避免对经常更新的表进行过多的索引，并且索引中的列尽可能少。而对经常用于查询的字段应该创建索引，但要避免添加不必要的字段
8. 当唯一性是某种数据本身的特征时，指定唯一索引
9. 在频繁进行排序或分组（即进行group by或order by操作）的列上建立索引


## 索引使用原则
### 索引失效
1. like 以%开头，索引无效；当like前缀没有%，后缀有%时，索引有效。
2. or语句前后没有同时使用索引。当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效
3. 组合索引——最左匹配原则：组合索引的底层实现仍是b+树，只是其排序方式是按照多个字段依次排序，因此有了最左匹配原则，即查询字段时必须要按照从左至右的方式查找，否则索引就会失效。
4. 数据类型出现隐式转化。如varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描。
5. 在索引列上使用 IS NULL 或 IS NOT NULL操作。索引是不索引空值的，所以这样的操作不能使用索引，可以用其他的办法处理，例如：数字类型，判断大于0，字符串类型设置一个默认值，判断是否等于默认值即可。
6. 在索引字段上使用not，<>，!= ，not in、not exist、。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。 优化方法： key<>0 改为 key>0 or key<0。
7. 对索引字段进行计算操作、字段上使用函数。（索引为 emp(ename,empno,sal)）
8. 当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效。
9. 当变量采用的是times变量，而表的字段采用的是date变量时.或相反情况
10. 建立索引的字段不能使用函数，这将导致索引失效而进行全表扫描
11. 不要在列上进行运算，这也将导致索引失效而进行全表扫描
12. 避免使用 != 或 not in或 <> 等否定操作符，也会导致索引失效
---
# High frequency questions


> MyISAM 存储引擎和 InnoDB 的索引有什么区别
* InnoDB是聚集索引，数据文件是和（主键）索引绑在一起的,通过主键索引到整个记录， 辅助索引先查询到主键，通过主键索引到整个记然
* MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的
* InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；
* 而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。

> 聚簇索引和非聚簇索引区别
* 聚簇索引的叶子节点就是数据节点
* 而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

> 为什么MySQL 索引中用B+tree，不用B-tree，
* 树的查询时间跟树的高度有关，B+树是一棵多路搜索树可以降低树的高度，提高查找效率
* MySQL并未使用红黑树作为索引的实现，主要原因在于红黑树只有两个子树,深度过大，数据检索时造成磁盘IO频繁
* B-Tree是一种自平衡的多叉搜索树，一个节点可以拥有两个以上的子节点,MySQL索引一般都存储在内存中,如果使用B-Tree作为索引的话,索引和数据存储在一块,一定内存的情况下可以存储的索引数量相对有限，毕竟每条数据的大小一般远大于索引列的大小，导致内存使用率不高.
* 而B-Tree和红黑树对于顺序查询并不友好，B+Tree的数据页只存储在叶子节点中，并且叶子节点之间通过指针相连，为双向链表结构,能够很好支持单值，范围查询，有序性查询
* B+树更适合外部存储(一般指磁盘存储),由于内节点(非叶子节点)不存储data,所以一个节点可以存储更多的内节点,每个节点能索引的范围更大更精确.也就是说使用B+树单次磁盘I/O的信息量相比较B树更大,I/O 效率更高。
* MySQL会按照区间来访问某个索引列,B+树的叶子节点间按顺序建立了链指针,加强了区间访问性,所以 B+树对索引列上的区间范围查询很友好.而B树每个节点的key和data在一起,无法进行区间查找


> 既然增加树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优的查找效率？

* 这样会形成一个有序数组，文件系统和数据库的索引都是存在硬盘上的,并且如果数据量大的话,不一定能一次性加载到内存中。
* 这时候B+树的多路存储，可以每次加载B+树的一个结点，然后一步步往下找

>  为什么不用Hash索引，聚簇索引/非聚簇索引，
* 哈希结构在单条数据的等值查询是性能非常优秀，但是只能用来搜索等值的查询
* 从内存角度上说，数据库中的索引一般时在磁盘上，数据量大的情况可能无法一次性装入内存，B+树的设计可以允许数据分批加载
* 从业务场景上说，如果只选择一个数据那确实是hash更快，但是数据库中经常会选中多条这时候由于B+树索引有序，并且又有链表相连，它的查询效率比hash就快很多了
 

> MySQL主键的设计原则

* 唯一标识一条记录，不能有重复的，不允许为空
* MySQL主键应该是单列的，以便提高连接和筛选操作的效率
* MySQL主键应当是对用户没有意义的。


> MySQL索引底层实现,叶子结点存放的是数据还是指向数据的内存地址，

> 使用索引需要注意的几个地方？使用索引查询一定能提高查询的性能吗？为什么?
1. 索引不会包含有 null 值的列
2. 使用短索引
3. 索引列排序
4. like 语句操作
5. 不使用 not in 和 <> 操作
6. 不要在列上进行运算
