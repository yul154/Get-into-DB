# MySQL 的基本架构

# Mysql 框架
![image](https://user-images.githubusercontent.com/27160394/140594674-19156356-f2ba-42d7-9401-b8cab5168324.png)

## 1. 网络连接层
客户端和连接服务。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。

### 组件
* Connectors:负责与其他编程语言的sql语言进行交互

## 2.服务层
>负责查询处理和其他系统任务。
主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储

### 组件
* 连接池组建 (Connection Pool): MySQL会为每一个连接绑定一个线程,之后这个连接上的所有查询都在这个线程中执行.MySQL通常会缓存线程或者使用线程池,从而避免频繁的创建和销毁线程。
* 管理服务和工具组建 (Enterprise Management Services & Utilities)
* SQL接口组件（SQL Interface）: MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口。
* 查询分析器（Parser): MySQL会解析SQL查询,并为其创建语法树,并根据数据字典丰富查询语法树,会验证该客户端是否具有执行该查询的权限.创建好语法树后,MySQL还会对SQl查询进行语法上的优化，进行查询重写
* 优化器组件（Optimizer）:语法解析和查询重写之后,MySQL会根据语法树和数据的统计信息对SQL进行优化,包括决定表的读取顺序、选择合适的索引等，最终生成SQL的具体执行步骤。这些具体的执行步骤里真正的数据操作都是通过预先定义好的存储引擎API来进行的，与具体的存储引擎实现无关
* 缓冲组件（Cache & Buffer）: MySQL内部维持着一些Cache和Buffer,比如Query Cache用来缓存一条Select语句的执行结果,如果能够在其中找到对应的查询结果,那么就不必再进行查询解析、优化和执行的整个过程了

## 3. 引擎层
> 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信

MySQL可以动态安装或移除存储引擎，可以有多种存储引擎同时存在，可以为每个Table设置不同的存储引擎。存储引擎负责在文件系统之上，管理表的数据、索引的实际内容，同时也会管理运行时的Cache、Buffer、事务、Log等数据和功能

### 组件
* Pluggable Storage Engine:负责与具体的文件系统交互
  * MySQL可以动态安装或移除存储引擎，可以有多种存储引擎同时存在，可以为每个Table设置不同的存储引擎。
  * 存储引擎负责在文件系统之上，管理表的数据、索引的实际内容，同时也会管理运行时的Cache、Buffer、事务、Log等数据和功能 

### 存储引擎类别
* InnoDB 存储引擎：Mysql 5.5版本后默认的存储引擎，优点是支持事务，行级锁，外键约束，支持崩溃后的安全恢复；
* MyISAM 存储引擎：不支持事务和外键，支持全文索引（但只对英文有效），特点是查询速度快；
* Memory 存储引擎：数据放在内存当中（类似memcache）以便得到更快的响应速度，但是崩掉的话数据会丢失；
* NDB 存储引擎：主要用于Mysql Cluster分布式集群；
* Archive 存储引擎：有很好的压缩机制，用于文件归档，写入时会进行压缩；

## 4.存储层

是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互

### 组件
* 物理文件(File System,Files & Logs): 所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统上，以文件的方式存在的
---
# MySQL 的查询流程具体是？or 一条SQL语句在MySQL中如何执行的

1. 客户端请求
2. 连接器（验证用户身份，给予权限）
3. 查询缓存（存在缓存则直接返回，不存在则执行后续操作）
4. 分析器（对SQL进行词法分析和语法分析操作）
5. 优化器（主要对执行的sql优化选择最优的执行方案方法）
6. 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）
7. 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）

4.存储层
是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互

组件
物理文件(File System,Files & Logs): 所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统上，以文件的方式存在的

----
## 一条SQL更新语句是如何执行的

1. 先连接数据库（连接器）
2. 在一个表上更新时，与该表有关的查询缓存会失效，所以该语句会将表T上所有的缓存结果都清空；
3. 将SQL语句进行词法分析，并检测SQL语法(分析器)
4. 然后优化对应的查询操作(优化器)
5. 执行器负责具体执行，找到这一行，进行更新

查询语句只需要返回查询结果即可，但是更新语句需要去真的修改数据库中的数据，所以更新语句相对来讲要复杂一些.更新流程还涉及两个重要的日志模块 redolog(重做日志)和 binlog(归档日志）

每一次的更新操作都需要写进磁盘,然后磁盘也要找到对应的那条记录,然后再更新,整个过程IO成本,查找成本都很高.MySQL的设计者Write-Ahead Logging，它的关键点就是先写日志，再写磁盘.
* 执行一条更新语句，InnoDB就会先把记录写到redo log里面，然后更新到内存，等到系统比较空闲的时候再写入磁盘。redo log的文件大小是固定的，是通过循环写的 实现的

*重做日志(redo log)和归档日志(binlog)*
Redo log
> 为了解决crash-safe问题而产生的，是一种物理日志
redo log是InnoDB引擎层的一种日志，是用来记录这个页"做了什么改动"
![image](https://user-images.githubusercontent.com/27160394/140596469-31603a55-eb39-48cb-8ff7-b7faa87a6b8b.png)
* redo log的文件大小是固定的，会循环写入文件,一边写一边后移，写到第3号文件末尾后就回到0号文件开头,checkpoint也是往后推移并且循环的,擦除记录前要把记录更新到数据文件
* write pos和checkpoint之间还空着的部分，可以用来记录新的操作
* 如果write pos追上checkpoin，表示redo log满了，这时候不能再执行新的更新，得停下来先擦掉一些记录

Binlog
> 一种逻辑日志，是Server层的一种日志，记录了所有的sql语句，主要是用来配合备份来恢复数据库的
只要我们有最近一次的备份和这期间完整的binlog就能够恢复数据库了
* binlog是追加写，写到一定大小后会切换到下一个，并不会覆盖以前的日志

两阶段提交
1. UPDATE语句的结果写入内存，同时将这个操作写入redo log，此时redo log处于prepare状态，并告知执行器随时可以提交事物
2. 执行器生成这个操作的binlog，并写入binlog日志. 
3. 执行器通知将之前处于prepare状态改为commit状态，更新完成。

两个阶段提交保证了redo log和binlog的一致性
* 先写redo log后写binlog,redo log会恢复crash的语句，但是如果用这产生时的binlog去恢复数据库就会丢失这条记录，此时两个日志恢复的数据库数据就产生了差异
* 先写binlog后写redo log,redo log中还没写,此时异常重启后这个事务是无效的,所以无法恢复,但是binlog中有这条数据,当用此时的binlog文件去恢复数据库的时候,就会比当前的数据库数据多一条记录。

执行器和InnoDB引擎在执行这个简单的update语句时的内部流程:
1. 执行器先找引擎取ID=2这一行，ID是主键，引擎直接用树搜索找到这一行，如果ID=2这一行所在的数据页本就在内存中，就直接返回给执行器，否则需要从磁盘读入再返回；
2. 执行器拿到引擎给的行数据后，将值加1，原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据；
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务
4. 执行器生成这个操作的binlog，并把binlog写入磁盘
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成
6. Redo log的写入拆成了两个步骤：prepare和commit，这就是"两阶段提交"。
7. 
![image](https://user-images.githubusercontent.com/27160394/140596830-ff8ff742-f9cc-4106-b40a-a4c76dbbec67.png)

Note
* Redo log不是记录数据页“更新之后的状态”，而是记录这个页 “做了什么改动”。
* Binlog有两种模式，statement 格式的话是记sql语句,row格式会记录行的内容,记两条,更新前和更新后都有。
