# MySQL 的基本架构

# Mysql 框架
![image](https://user-images.githubusercontent.com/27160394/140594674-19156356-f2ba-42d7-9401-b8cab5168324.png)

## 1. 网络连接层
客户端和连接服务。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。

### 组件
* Connectors:负责与其他编程语言的sql语言进行交互

## 2.服务层
>负责查询处理和其他系统任务。
主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储

### 组件
* 连接池组建 (Connection Pool): MySQL会为每一个连接绑定一个线程,之后这个连接上的所有查询都在这个线程中执行.MySQL通常会缓存线程或者使用线程池,从而避免频繁的创建和销毁线程。
* 管理服务和工具组建 (Enterprise Management Services & Utilities)
* SQL接口组件（SQL Interface）: MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口。
* 查询分析器（Parser): MySQL会解析SQL查询,并为其创建语法树,并根据数据字典丰富查询语法树,会验证该客户端是否具有执行该查询的权限.创建好语法树后,MySQL还会对SQl查询进行语法上的优化，进行查询重写
* 优化器组件（Optimizer）:语法解析和查询重写之后,MySQL会根据语法树和数据的统计信息对SQL进行优化,包括决定表的读取顺序、选择合适的索引等，最终生成SQL的具体执行步骤。这些具体的执行步骤里真正的数据操作都是通过预先定义好的存储引擎API来进行的，与具体的存储引擎实现无关
* 缓冲组件（Cache & Buffer）: MySQL内部维持着一些Cache和Buffer,比如Query Cache用来缓存一条Select语句的执行结果,如果能够在其中找到对应的查询结果,那么就不必再进行查询解析、优化和执行的整个过程了

## 3. 引擎层
> 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信

MySQL可以动态安装或移除存储引擎，可以有多种存储引擎同时存在，可以为每个Table设置不同的存储引擎。存储引擎负责在文件系统之上，管理表的数据、索引的实际内容，同时也会管理运行时的Cache、Buffer、事务、Log等数据和功能

### 组件
* Pluggable Storage Engine:负责与具体的文件系统交互
  * MySQL可以动态安装或移除存储引擎，可以有多种存储引擎同时存在，可以为每个Table设置不同的存储引擎。
  * 存储引擎负责在文件系统之上，管理表的数据、索引的实际内容，同时也会管理运行时的Cache、Buffer、事务、Log等数据和功能 

### 存储引擎类别
* InnoDB 存储引擎：Mysql 5.5版本后默认的存储引擎，优点是支持事务，行级锁，外键约束，支持崩溃后的安全恢复；
* MyISAM 存储引擎：不支持事务和外键，支持全文索引（但只对英文有效），特点是查询速度快；
* Memory 存储引擎：数据放在内存当中（类似memcache）以便得到更快的响应速度，但是崩掉的话数据会丢失；
* NDB 存储引擎：主要用于Mysql Cluster分布式集群；
* Archive 存储引擎：有很好的压缩机制，用于文件归档，写入时会进行压缩；

## 4.存储层

是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互

### 组件
* 物理文件(File System,Files & Logs): 所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统上，以文件的方式存在的
---
# MySQL 的查询流程具体是？or 一条SQL语句在MySQL中如何执行的

1. 客户端请求
2. 连接器（验证用户身份，给予权限）
3. 查询缓存（存在缓存则直接返回，不存在则执行后续操作）
4. 分析器（对SQL进行词法分析和语法分析操作）
5. 优化器（主要对执行的sql优化选择最优的执行方案方法）
6. 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）
7. 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）

## 连接
长连接和短连接
* 长连接: 长连接指在一个连接上可以连续发送多个数据包,在连接保持期间,如果没有数据包发送,需要双方发链路检测包.我理解 MySQL 默认的超时时间 8 小时，就属于一个长链接
* 短连接：是指通讯双方有数据交互时，就建立一个连接，数据发送完成后，则断开此连接，即每次连接只完成一项业务的发送

使用长连接后,随着连接数不断增加,会导致内存占用升高，因为MySQL在操作过程中会占用内存来管理连接对象，只有等到连接断开后才会释放。
* 如果连接一直堆积，就会导致内存占用过大，被系统强行杀掉，也就是会出现 MySQL 重启。

## 查询缓存
> 在解析一个查询语句之前，如果查询缓存是打开的，那么 MySQL 会优先检查这个查询是否命中查询缓存中的数据。
如果当前的查询恰好命中了查询缓存，那么在返回查询结果之前 MySQL 会检查一次用户权限。若权限没有问题，MySQL 会跳过所有其他阶段（解析、优化、执行等），直接从缓存中拿到结果并返回给客户端。

**缓存哪里来的**
mysql query cache 的内容为 select 的结果集，在内存中是以 HASH 结构来进行映射。
* cache会使用完整的`sql`字符串做key，并区分大小写,空格等。即两个`sql`必须完全一致才会导致 cache命中。

**缓存何时失效？**
在表的结构或数据发生改变时，查询缓存中的数据不再有效。
* 旦表数据进行任何一行的修改，基于该表相关 cache 立即全部失效，并且从缓冲区中移出

**缓存可以提高查询效率的？**

* 当有大量的查询和大量的修改时，cache 机制可能会造成性能下降。
* 因为每次修改会导致系统去做 cache 失效操作，这就会造成不小的开销。
* 另外系统 cache 的访问由一个单一的全局锁来控制，这时候大量的查询将被阻塞，直至锁释放。
* 所以不要简单认为设置 cache 必定会带来性能提升

## 解析器

1. 词法解析: 词法分析的作用是将整个查询分解为多个元素
2. 语法分析:语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法,并为其创建语法树,提供给优化器使用

## 优化器
MySQL 的优化器有几个重要任务：
1、选择最合适的索引；
2、选择表扫还是走索引；
3、选择表关联顺序；
4、优化 where 子句；
5、排除管理中无用表；
6、决定 order by 和 group by 是否走索引；
7、尝试使用 inner join 替换 outer join；
8、简化子查询，决定结果缓存；
9、合并试图；

但是其中最主要的目标是尽可能地使用索引，并且使用最严格的索引来消除尽可能多的数据行

## 执行器
1. 会先判断是否有操作权限，若没有，会抛出相关异常。
2. 如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口

执行器的执行流程
1、调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；
2、调用引擎接口取下一行，重复相同的判断逻辑，直到取到这个表的最后一行。
3、执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。
----
## 一条SQL更新语句是如何执行的

1. 先连接数据库（连接器）
2. 在一个表上更新时，与该表有关的查询缓存会失效，所以该语句会将表T上所有的缓存结果都清空；
3. 将SQL语句进行词法分析，并检测SQL语法(分析器)
4. 然后优化对应的查询操作(优化器)
5. 执行器负责具体执行，找到这一行，进行更新

重点放在执行器<->存储引擎之间的交互
> 查询语句只需要返回查询结果即可，但是更新语句需要去真的修改数据库中的数据，所以更新语句相对来讲要复杂一些.更新流程还涉及两个重要的日志模块 redolog(重做日志)和 binlog(归档日志）

mysql不是每次数据更改都立刻写到磁盘,而是会先将修改后的结果暂存在内存中当一段时间后，再一次性将多个修改写到磁盘上，减少磁盘io成本，同时提高操作速度高.
* MySQL的设计者Write-Ahead Logging，它的关键点就是先写日志，再写磁盘.
* 执行一条更新语句，InnoDB就会先把记录写到redo log里面，然后更新到内存，等到系统比较空闲的时候再写入磁盘。redo log的文件大小是固定的，是通过循环写的实现的

*重做日志(redo log)和归档日志(binlog)*

Redo log
> 为了解决crash-safe问题而产生的，是一种物理日志，是用来记录这个页"做了什么改动"，它用来恢复提交后的物理数据页

持久性:只要事务提交成功，那么对数据库做的修改就被永久保存下来了，不可能因为任何原因再回到原来的状态
* 每次事务提交的时候，将该事务涉及修改的数据页全部刷新到磁盘中
 * 因为 Innodb 是以页为单位进行磁盘交互的，而一个事务很可能只修改一个数据页里面的几个字节，这个时候将完整的数据页刷到磁盘的话，太浪费资源了！
 * 一个事务可能涉及修改多个数据页，并且这些数据页在物理上并不连续，使用随机IO写入性能太差！

redo log包括两部分
* 内存中的日志缓冲(redo log buffer)
* 磁盘上的日志文件(redo logfile)

生成的日志都得先保存起来,但又不能在还没commit的时候就直接写到 redo log 文件
* mysql每执行一条DML语句,先将记录写入 redo log buffer
* 后续某个时间点再一次性将多个操作记录写到redo log file.
* 这种先写日志,再写磁盘的技术就是 MySQL里经常说到的 WAL(Write-Ahead Logging) 技术。
* 如果发生宕机，则读取磁盘上的 redo log file 进行数据的恢复

![image](https://user-images.githubusercontent.com/27160394/140596469-31603a55-eb39-48cb-8ff7-b7faa87a6b8b.png)

redo log 实际上记录数据页的变更，而这种变更记录是没必要全部保存
* redo log的文件大小是固定的，会循环写入文件,一边写一边后移，写到第3号文件末尾后就回到0号文件开头,checkpoint也是往后推移并且循环的,擦除记录前要把记录更新到数据文件
* write pos和checkpoint之间还空着的部分，可以用来记录新的操作
* check point 到 write pos 之间是 redo log 待落盘的数据页更改记录
* 如果write pos追上checkpoin，表示redo log满了，这时候不能再执行新的更新，得停下来先擦掉一些记录

redo log的大小是固定的，日志上的记录修改落盘后，日志会被覆盖掉，无法用于数据回滚/数据恢复等操作。


Binlog
> 一种逻辑日志，是Server层的一种逻辑日志，记录了所有的sql语句，主要是用来配合备份来恢复数据库的，以二进制的形式保存在磁盘中
只要我们有最近一次的备份和这期间完整的binlog就能够恢复数据库了
* binlog是追加写，写到一定大小后会切换到下一个，并不会覆盖以前的日志

binlog 日志有三种格式
* STATMENT:基于SQL语句的复制( statement-based replication,SBR),每一条会修改数据的sql语句会记录到 binlog 中
* ROW:基于行的复制(row-based replication,RBR),不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了



## 两阶段提交

执行器和InnoDB引擎在执行这个简单的update语句时的内部流程:
1. 执行器先找引擎取ID=2这一行，ID是主键，引擎直接用树搜索找到这一行，如果ID=2这一行所在的数据页本就在内存中，就直接返回给执行器，否则需要从磁盘读入再返回；
2. 执行器拿到引擎给的行数据后，更新数据，再调用引擎接口写入这行新数据；
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务
4. 执行器生成这个操作的binlog，并把binlog写入磁盘
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成
6. Redo log的写入拆成了两个步骤：prepare和commit，这就是"两阶段提交"。


![image](https://user-images.githubusercontent.com/27160394/140596830-ff8ff742-f9cc-4106-b40a-a4c76dbbec67.png)


1. UPDATE语句的结果写入内存，同时将这个操作写入redo log，此时redo log处于prepare状态，并告知执行器随时可以提交事物
2. 执行器生成这个操作的binlog，并写入binlog日志. 
3. 执行器通知将之前处于prepare状态改为commit状态，更新完成。

两个阶段提交： 保证了redo log和binlog的一致性
* 先写redo log后写binlog,因为redo log写完了，恢复系统的时候name='god-jiang'.但是binlog没有写完,所以binlog没有记录这条语句,这个时候用binlog恢复数据的时候,恢复出来的name就是原来值,与redo log不同。
* 先写binlog后写redo log,redo log中还没写,此时异常重启后这个事务是无效的,所以无法恢复,但是binlog中有这条数据,当用此时的binlog文件去恢复数据库的时候,就会比当前的数据库数据多一条记录。



Note
* Redo log不是记录数据页“更新之后的状态”，而是记录这个页 “做了什么改动”。
* Binlog有两种模式，statement 格式的话是记sql语句,row格式会记录行的内容,记两条,更新前和更新后都有。

## 这两种日志区别
* redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
* redo log 是物理日志，记录的是 “在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如 “给 ID=2 这一行的 c 字段加 1
* redo log大小是固定的,是循环写的,空间固定会用完；binlog 是可以追加写入的。“追加写” 是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志
*  binlog 日志只用于归档，只依靠 binlog 是没有crash-safe 能力的. 只有 redo log 也不行,日志上的记录落盘后会被覆盖掉

* 逻辑日志： 可以简单理解为记录的就是sql语句 。
* 物理日志： mysql数据最终是保存在数据页中的，物理日志记录的就是数据页变更 。
